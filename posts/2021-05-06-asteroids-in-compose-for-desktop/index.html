<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta property="og:title" content="How I built an &#34;Asteroids&#34; game using Compose for Desktop (Part 1/2)"><meta property="og:description" content="...and how you can get started building your own games on top of this modern framework."><meta property="og:type" content="article"><meta property="og:url" content="https://sebi.io/posts/2021-05-06-asteroids-in-compose-for-desktop/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-06T00:00:00+00:00"><title>How I built an "Asteroids" game using Compose for Desktop (Part 1/2) | Sebastian Aigner</title><link rel=stylesheet href=https://sebi.io/sass/main.1062dd691b84b3ea042cce5aecb22abbae6d1a58288b48fbcb72443c8f1930dd.css integrity="sha256-EGLdaRuEs+oELM5a7LIqu65tGlgoi0j7y3JEPI8ZMN0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">How I built an "Asteroids" game using Compose for Desktop (Part 1/2)</h1><p class=post-meta><time class=dt-published datetime=2021-05-06T00:00:00+00:00>May 6, 2021</time></p></header><div class="post-content e-content"><p>A while ago, I <a href=https://twitter.com/sebi_io/status/1382668779377762305>tweeted</a> about a small game I had created on top of <a href=https://www.jetbrains.com/lp/compose/><strong>Compose for Desktop</strong></a>: A small clone of the <strong>classic arcade game</strong> <a href=https://en.wikipedia.org/wiki/Asteroids_(video_game)><strong>Asteroids</strong></a>, in which you control a space ship with your mouse, and navigate the vastness of space, avoiding and breaking asteroids in the process.</p><p><video controls src=/assets/asteroids-cfd/tweet.mp4></video></p><p>Today, it&rsquo;s time to take a look under the hood and understand how I built a basic version of this game, and how <strong>Compose for Desktop helped me achieve it in just one evening</strong>!</p><p>We will take a look at parts and structures in the code that I find the most interesting. To see how it all fits together, I suggest exploring the <a href=https://github.com/SebastianAigner/asteroids-compose-for-desktop><strong>whole code on GitHub</strong></a>. The whole implementation is <strong>only 300 lines of code</strong>, which I hope makes studying and understanding it easy.</p><h3 id=the-game>The Game</h3><p>If you&rsquo;re not caught up on your 80s arcade trivia, <a href=https://en.wikipedia.org/wiki/Asteroids_(video_game)>Asteroids</a> was a popular arcade game where you try to steer your space ship through space, avoiding and destroying asteroids with your ship.</p><p>Because of the limitations of the hardware at the time, the game is quite simplistic in appearance: a triangular spaceship moves across a plain background and avoids simple displays of asteroids on a 2D surface.</p><p>What makes this a challenge is the <em>interia</em>: Just like a real space ship, your spaceship moves along its course in a straight line at constant speed, and you need to make corrective maneuvers by turning your ship and directing your thrust.</p><p><strong>Asteroids has achieved cult status in the arcade game scene.</strong> Because of that, I wanted to see what it would take to recreate this experience using Compose for Desktop!</p><h3 id=the-building-blocks>The Building Blocks</h3><p>I have roughly divided the project into a few building blocks that make up the project, and that we will talk about. Namely, those are:</p><ul><li><a href=#the-game-loop><strong>The Game Loop</strong></a></li><li><a href=#state><strong>Game State Management</strong></a></li><li><a href=#rendering><strong>Rendering to the Screen</strong></a></li></ul><p>In the <strong>second part</strong> of this series on building a game with Compose for Desktop, we will also look at additional <strong>rendering details</strong>, the <strong>geometry and linear algebra</strong> behind the game, and <strong>frame-independent movement</strong>.</p><p>Let&rsquo;s dive right in!</p><h2 id=the-game-loop-a-namethe-game-loopa>The Game Loop <a name=the-game-loop></a></h2><p>At the center of most games stands the <strong>game loop</strong>. It acts as the <strong>entry point</strong> that calls the game logic code. This is a fundamental difference between implementing typical declarative user interfaces and building games:</p><ul><li><strong>Declarative UI</strong> is usually mostly static, and reacts to user actions (clicking, dragging) or other events (new data, computation progress&mldr;)</li><li><strong>Games</strong> run their logic many times per second, simulating the game world and its entities one frame at a time.</li></ul><p>That is not to say that these two approaches are incompatible! All we need to run a main &ldquo;game loop&rdquo; is to get our <strong>function to execute</strong> once per frame. In Compose, we have the <code>withFrame</code> family of functions (<code>withFrameMillis</code>, <code>withFrameNanos</code>), which can help us achieve exactly that.</p><p>Let&rsquo;s assume we already have a <code>game</code> object – we will talk about state management shortly. We can then create a <code>LaunchedEffect</code> which asks Compose for Desktop to <strong>call our <code>update</code> function whenever a new frame is rendered</strong>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>LaunchedEffect(Unit) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>while</span> (<span style=color:#fe8019>true</span>) {
</span></span><span style=display:flex><span>        withFrameNanos {
</span></span><span style=display:flex><span>            game.update(<span style=color:#fe8019>it</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>withFrameNanos</code> is a suspending method. Its exact implementation is described in the <a href=https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#withframemillis>documentation</a>:</p><blockquote><p><code>withFrameNanos</code> suspends until a new frame is requested, immediately invokes <code>onFrame</code> with the frame time in nanoseconds in the calling context of frame dispatch, then resumes with the result from <code>onFrame</code>.</p></blockquote><p>The frame time, which it provides us with, will also come in handy, as we will see in the second part of this blog post series, when we talk about <em>frame-independent movement</em>.</p><h2 id=game-state-management-a-namestatea>Game State Management <a name=state></a></h2><p><strong>Compose is excellent at managing state</strong>, and when building a game like Asteroids, we can use the same mechanisms to keep track of the data attached to game objects or the current play session, to name just two examples.</p><p>As suggested in the previous section, my Asteroids game has a <code>Game</code> class, an instance of which is wrapped in a <code>remember</code> call in the main composition.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> game = remember { Game() }
</span></span></code></pre></div><p>It acts as a container for all game-related data. For example:</p><ul><li>Game object information (in a <code>mutableStateListOf</code>)</li><li>The current game phase (<code>RUNNING</code> / <code>STOPPED</code>)</li><li>The size of the playing field (based on window dimensions)</li></ul><p>Inside the <code>Game</code> object, we treat the state data as mutable, and make any state changes as we see fit.</p><h3 id=game-objects>Game Objects</h3><p>Individual game objects once again group the state belonging to an individual game entity: a spaceship, an asteroid, or a bullet, and provide methods to modify their state, spawn new game objects, or check their relation to other game objects.</p><p>In my implementation of Asteroids, all game objects share a lot of behavior, from the way they move through the environment to how they check their collision – we&rsquo;ll talk about the geometry and linear algebra that goes into that a bit later.</p><p>The <code>GameObject</code> class provides implementations for these shared behaviors:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>sealed</span> <span style=color:#fe8019>class</span> GameObject(speed: Double = <span style=color:#d3869b>0.0</span>, angle: Double = <span style=color:#d3869b>0.0</span>, position: Vector2 = Vector2.ZERO) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>var</span> speed <span style=color:#fe8019>by</span> mutableStateOf(speed)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>var</span> angle <span style=color:#fe8019>by</span> mutableStateOf(angle)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>var</span> position <span style=color:#fe8019>by</span> mutableStateOf(position)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>var</span> movementVector <span style=color:#928374;font-style:italic>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>abstract</span> <span style=color:#fe8019>val</span> size: Double
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>fun</span> <span style=color:#fabd2f>update</span>(realDelta: Float, game: Game) {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>val</span> velocity = movementVector * realDelta.toDouble()
</span></span><span style=display:flex><span>        position <span style=color:#fe8019>+=</span> velocity
</span></span><span style=display:flex><span>        position = position.mod(Vector2(game.width.<span style=color:#fe8019>value</span>.toDouble(), game.height.<span style=color:#fe8019>value</span>.toDouble()))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>fun</span> <span style=color:#fabd2f>overlapsWith</span>(other: GameObject): Boolean {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>return</span> <span style=color:#fe8019>this</span>.position.distanceTo(other.position) &lt; (<span style=color:#fe8019>this</span>.size / <span style=color:#d3869b>2</span> + other.size / <span style=color:#d3869b>2</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For example, the <code>ShipData</code> class inherits <code>speed</code>, <code>angle</code>, <code>position</code> and its <code>update</code> method from <code>GameObject</code>, but defines its own size, angle, and a function to fire a bullet:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>class</span> ShipData : GameObject() {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>override</span> <span style=color:#fe8019>var</span> size: Double = <span style=color:#d3869b>40.0</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>var</span> visualAngle: Double = <span style=color:#d3869b>0.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>fun</span> <span style=color:#fabd2f>fire</span>(game: Game) {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>val</span> ship = <span style=color:#fe8019>this</span>
</span></span><span style=display:flex><span>        game.gameObjects.add(BulletData(ship.speed * <span style=color:#d3869b>4.0</span>, ship.visualAngle, ship.position))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that the <code>ShipData</code> (or even a <code>GameObject</code> in general) does not include any logic on how to render this item to the display – <strong>with Compose, keeping state and presentation separated is quite easy</strong>.</p><p>Because a lot of behavior is shared between all types of entities in the game, our main game loop can treat them as the supertype <code>GameObject</code> for the most part, and only specific interactions between certain types of objects, like bullet-asteroid or asteroid-player collisions, need to be handled specifically.</p><h2 id=rendering-to-the-screen-a-namerenderinga>Rendering to the Screen <a name=rendering></a></h2><p>I found that in Compose, <strong>separating game data from the visual representation comes quite naturally</strong>. Game objects like a ship, an asteroid, or a bullet are all represented in two parts:</p><ul><li>A class holding the state associated with the game object (in terms of &ldquo;Compose state&rdquo; – via <code>mutableStateOf</code> and friends) – We briefly talked about this in the previous section.</li><li>A <code>@Composable</code>, defining the rendering based on the game object&rsquo;s data.</li></ul><p>To illustrate the latter, here&rsquo;s the minimal visual representation of the <code>Asteroid</code> composable. It receives <code>asteroidData</code>, which is the container for all information regarding the state of this particular game object:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Composable
</span></span><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>Asteroid</span>(asteroidData: AsteroidData) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> asteroidSize = asteroidData.size.dp
</span></span><span style=display:flex><span>    Box(
</span></span><span style=display:flex><span>    Modifier
</span></span><span style=display:flex><span>    .offset(asteroidData.xOffset, asteroidData.yOffset)
</span></span><span style=display:flex><span>    .size(asteroidSize)
</span></span><span style=display:flex><span>    .rotate(asteroidData.angle.toFloat())
</span></span><span style=display:flex><span>    .clip(CircleShape)
</span></span><span style=display:flex><span>    .background(Color(<span style=color:#d3869b>102</span>, <span style=color:#d3869b>102</span>, <span style=color:#d3869b>153</span>))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code snippet is enough to <strong>describe the whole visual representation</strong> of an asteroid.</p><p>We start with a <a href=https://developer.android.com/jetpack/compose/layout><code>Box</code></a> – one of Compose&rsquo;s most basic layout primitives, which allows us to have entities overlap (which is useful since we manually take care of placing the individual entities). We then use Compose&rsquo;s <a href=https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier><code>Modifier</code>s</a> to specify the position of the asteroid in the form of an <code>offset</code>, its size, rotation angle, shape (by clipping a <code>CircleShape</code>), and background color.</p><p>Note that Compose offers quite <strong>high-level APIs even for these basic shapes</strong> – for example, we can use <code>.rotate</code> directly, without having to manually do geometry work to figure out how to get our entities facing the right way.</p><p>To keep this snippet as concise as possible, I&rsquo;ve also introduced some extension functions on <code>GameObject</code> that make it possible to reuse the logic of computing the offset of a game object based on its position and size, called <code>xOffset</code> and <code>yOffset</code>, which I&rsquo;ve snuck into the previous code snippet already. Their implementation is relatively straightforward:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> GameObject.xOffset: Dp <span style=color:#fe8019>get</span>() = position.x.dp - (size.dp / <span style=color:#d3869b>2</span>)
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> GameObject.yOffset: Dp <span style=color:#fe8019>get</span>() = position.y.dp - (size.dp / <span style=color:#d3869b>2</span>)
</span></span></code></pre></div><p>A slightly more complicated composable would be the <code>Ship</code> component, which combines the shapes of a triangle and circle to create a minimalistic spaceship:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Composable
</span></span><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>Ship</span>(shipData: ShipData) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> shipSize = shipData.size.dp
</span></span><span style=display:flex><span>    Box(
</span></span><span style=display:flex><span>    Modifier
</span></span><span style=display:flex><span>    .offset(shipData.xOffset, shipData.yOffset)
</span></span><span style=display:flex><span>    .size(shipSize)
</span></span><span style=display:flex><span>    .rotate(shipData.visualAngle.toFloat())
</span></span><span style=display:flex><span>    .clip(CircleShape)
</span></span><span style=display:flex><span>    .background(Color.Black)
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        Canvas(modifier = Modifier.fillMaxSize(), onDraw = {
</span></span><span style=display:flex><span>            drawPath(
</span></span><span style=display:flex><span>            color = Color.White,
</span></span><span style=display:flex><span>            path = Path().apply {
</span></span><span style=display:flex><span>                <span style=color:#fe8019>val</span> size = shipSize.toPx()
</span></span><span style=display:flex><span>                moveTo(<span style=color:#d3869b>0f</span>, <span style=color:#d3869b>0f</span>) <span style=color:#928374;font-style:italic>// Top-left corner...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>                lineTo(size, size / <span style=color:#d3869b>2f</span>) <span style=color:#928374;font-style:italic>// ...to right-center...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>                lineTo(<span style=color:#d3869b>0f</span>, size) <span style=color:#928374;font-style:italic>// ... to bottom-left corner.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>            }
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Box</code> defining the ship is quite similar to the one we saw for an <code>Asteroid</code>, but we additionally add a <code>Canvas</code> to draw some additional shapes on top of our spaceship – in this case, a triangle path. In typical Compose fashion, we just add this <code>Canvas</code> in the lambda block following our <code>Box</code>, meaning the <code>Canvas</code> will inhert the coordinate system of its parent, including its offset and rotation.</p><p>These composables are then just rendered to a <em>play surface</em> – nothing more than a <code>Box</code> with a locked aspect ratio of <code>1.0f</code> (to keep it quadratic). Of course, applying some artistic talent to these visual representations of the game is also possible, but we&rsquo;re keeping it minimal for now.</p><h2 id=continued-in-part-2>Continued in Part 2</h2><p>There&rsquo;s still a bit more work to do until we can call our game done. In part 2 of this blog post series, we will look at additional rendering details, the geometry and linear algebra behind the game&rsquo;s simple physics simulation, as well as frame-independent movement.</p><div><div>Tags:</div><ul><li><a href=/tags/gamedev/>gamedev</a></li><li><a href=/tags/kotlin/>kotlin</a></li><li><a href=/tags/jetpackcompose/>jetpackcompose</a></li><li><a href=/tags/android/>android</a></li></ul></div></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>