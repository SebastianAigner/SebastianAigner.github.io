<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta property="og:title" content="Tips & tricks for building a game using Compose for Desktop (Part 2/2)"><meta property="og:description" content="Diving deeper into building a sample game with the multiplatform reactive UI framework."><meta property="og:type" content="article"><meta property="og:url" content="https://sebi.io/posts/2021-05-06-tips-and-tricks-building-a-game-in-compose-for-desktop/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-06T00:00:00+00:00"><title>Tips & tricks for building a game using Compose for Desktop (Part 2/2) | Sebastian Aigner</title><link rel=stylesheet href=https://sebi.io/sass/main.1062dd691b84b3ea042cce5aecb22abbae6d1a58288b48fbcb72443c8f1930dd.css integrity="sha256-EGLdaRuEs+oELM5a7LIqu65tGlgoi0j7y3JEPI8ZMN0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Tips & tricks for building a game using Compose for Desktop (Part 2/2)</h1><p class=post-meta><time class=dt-published datetime=2021-05-06T00:00:00+00:00>May 6, 2021</time></p></header><div class="post-content e-content"><p>In the <strong>first part of my blog post series</strong> about building a small clone of the classic arcade game <a href=https://en.wikipedia.org/wiki/Asteroids_(video_game)><strong>Asteroids</strong></a> on top of Compose for Desktop, we saw how to implement the main game loop, as well as manage state and draw basic shapes. In this post, we will explore some more details of the game implementation. This includes:</p><ul><li><strong>Rendering details</strong> – making sure game objects don&rsquo;t escape our play area, and using a device-independent coordinate system for rendering</li><li><strong>Geometry and linear algebra</strong> – the <em>secret sauce</em> that makes the space ships fly</li><li><strong>Frame-independent movement</strong> – so that our game works consistently.</li></ul><p>Let&rsquo;s learn about these topics!</p><h2 id=rendering-clipping-and-coordinate-systems>Rendering: Clipping and Coordinate Systems</h2><p>In the context of rendering, there are two areas that still need our attention – we need to make sure that our <strong>game objects are constrained to the game surface</strong>, and we need to make a conscious decision about the <strong>units of the coordinates</strong> we use to describe the position of a game object. We&rsquo;ll discuss both in this section.</p><h3 id=clipping>Clipping</h3><p>By default, Compose naively draws your objects without any clipping. This means game objects can poke outside the &ldquo;play surface&rdquo;, which produces a weirdly fourth-wall-breaking effect:</p><p><img src=/assets/asteroids-cfd2/1xh0d39znpo8w97djsab.png alt="game objects escaping the bounds of reality"></p><p>We <strong>constrain the game objects to the bounds</strong> of our play surface by applying <code>Modifier.clipToBounds()</code> to the <code>Box</code> which defines our play surface:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>Box(modifier = Modifier
</span></span><span style=display:flex><span>                .fillMaxWidth()
</span></span><span style=display:flex><span>                .fillMaxHeight()
</span></span><span style=display:flex><span>                .clipToBounds()
</span></span><span style=display:flex><span>                <span style=color:#928374;font-style:italic>// . . .
</span></span></span></code></pre></div><p>Because all our game elements are drawn as children of this play area <code>Box</code>, using this modifier causes the rendered entities inside it to be cut off at the edges (instead of being drawn over the surrounding user interface):</p><p><img src=/assets/asteroids-cfd2/0zvlctk9ajr379k1m4rv.png alt="game objects staying snugly inside the play area"></p><h3 id=device-independent-pixels-and-density>Device-Independent Pixels and Density</h3><p>Something else to be aware of when doing any kind of rendering tasks in Compose for Desktop is to <strong>keep the units of measurement in the back of your mind</strong>.</p><p>Wherever I worked with coordinates, I decided to work in <a href=https://developer.android.com/reference/kotlin/androidx/compose/ui/unit/Dp><strong>device-independent pixels</strong></a>:</p><ul><li>The <strong>mouse pointer position</strong> is stored as a <code>DpOffset</code></li><li><strong>Game width</strong> and <strong>height</strong> are stored as <code>Dp</code>s</li><li><strong>Game objects</strong> are placed on the play surface using their <code>.dp</code> coordinates.</li></ul><p>This helps the game work consistently across high-density displays and low-density displays alike. However, it also <strong>requires some operations to be performed in the context of <code>Density</code></strong>.</p><p>For example, the <code>pointerMoveFilter</code> returns an <code>Offset</code> in pixels – and <strong>they are not device-independent</strong>!. To work around this, we obtain the local screen density in our composition:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> density = LocalDensity.current
</span></span></code></pre></div><p>We then use <code>with(density)</code> to access the <code>toDp()</code> extension functions to the <code>Offset</code> into a <code>DpOffset</code>, allowing us to store our <code>targetLocation</code> in this device-independent pixel format:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>.pointerMoveFilter(onMove = {
</span></span><span style=display:flex><span>    with(density) {
</span></span><span style=display:flex><span>        game.targetLocation  = DpOffset(<span style=color:#fe8019>it</span>.x.toDp(), <span style=color:#fe8019>it</span>.y.toDp())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fe8019>false</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>For storing the play area&rsquo;s width and height, we do a very similar thing, just without wrapping it in a <code>DpOffset</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>.onSizeChanged {
</span></span><span style=display:flex><span>    with(density) {
</span></span><span style=display:flex><span>        game.width = <span style=color:#fe8019>it</span>.width.toDp()
</span></span><span style=display:flex><span>        game.height = <span style=color:#fe8019>it</span>.height.toDp()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=a-game-of-geometry-and-linear-algebra-a-namegeometrya>A Game of Geometry and Linear Algebra <a name=geometry></a></h2><p>Underneath the visualization, the &ldquo;Asteroids&rdquo; game builds on just a few basic blocks to implement its mechanics – it is really a game of vectors and linear algebra:</p><ul><li>The <strong>position</strong>, <strong>movement</strong>, and <strong>acceleration</strong> of the ship can be described by <em>position, movement, and acceleration vectors</em>.</li><li>The <strong>orientation</strong> of the ship is the <em>angle</em> of the <em>vector</em> between the ship and the cursor.</li><li><strong>Circle-circle collisions</strong> can be tested based on <em>distance vectors</em>.</li></ul><p>Instead of reinventing the <del>wheel</del> vector, I decided to use <code>openrndr-math</code>, which includes an implementation of the <code>Vector2</code> class including all common operations, like scalar multiplication, addition, subtraction, the dot product, and more. (Ever since listening to the <a href=https://talkingkotlin.com/openrndr-with-edwin-jakobs/>Talking Kotlin</a> episode, I&rsquo;ve been meaning to explore <a href=https://openrndr.org/>OPENRNDR</a> in detail, but that will have to happen in a separate project.)</p><p><a href=https://api.openrndr.org/openrndr-math/openrndr-math/org.openrndr.math/-vector2/index.html><img src=/assets/asteroids-cfd2/4t373i87ll0hb6e6zsvn.png alt="OPENRNDR Vector2"></a></p><p>As somebody who happens to be a bit rusty with their linear algebra skills, I extended the functionality of the class a bit. For example, I defined the following extension function to allow me to access the angle a <code>Vector2</code> in degrees between 0-360:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>Vector2</span>.angle(): Double {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> rawAngle = atan2(y = <span style=color:#fe8019>this</span>.y, x = <span style=color:#fe8019>this</span>.x)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> (rawAngle / Math.PI) * <span style=color:#d3869b>180</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Thankfully, I did not have to spend too much time on figuring out the call to <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.math/atan2.html><code>atan2</code></a>, because I previously watched one of <a href=http://twitter.com/intelligibabble>Leland Richardson</a>&rsquo;s <a href="https://www.youtube.com/watch?v=fwn7olJOc70">live streams</a> where he also uses this function to calculate some angles.</p><p>Extensions like this one help me express ideas in ways I understand them myself – and hopefully still will a few months down the road.</p><p>I also made use of properties with <a href=https://kotlinlang.org/docs/properties.html#getters-and-setters>backing fields</a> to make it possible to access a <code>GameObject</code>&rsquo;s movement vector in different representations:</p><ul><li>As a combination of <strong>length</strong> (speed) and <strong>angle</strong></li><li>As a vector with <code>x</code> and <code>y</code> coordinates</li></ul><p>In the context of a <code>GameObject</code>, that can look like the following, for example:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>var</span> speed <span style=color:#fe8019>by</span> mutableStateOf(speed)
</span></span><span style=display:flex><span><span style=color:#fe8019>var</span> angle <span style=color:#fe8019>by</span> mutableStateOf(angle)
</span></span><span style=display:flex><span><span style=color:#fe8019>var</span> position <span style=color:#fe8019>by</span> mutableStateOf(position)
</span></span><span style=display:flex><span><span style=color:#fe8019>var</span> movementVector
</span></span><span style=display:flex><span>    <span style=color:#fe8019>get</span>() = (Vector2.UNIT_X * speed).rotate(angle)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>set</span>(<span style=color:#fe8019>value</span>) {
</span></span><span style=display:flex><span>        speed = <span style=color:#fe8019>value</span>.length
</span></span><span style=display:flex><span>        angle = <span style=color:#fe8019>value</span>.angle()
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>If we&rsquo;re using this functionality outside of the <code>GameObject</code> class a lot, we could also consider defining additional <code>length</code> / <code>angle</code> getters and setters as extension properties on the <code>Vector2</code> class, directly.</p><p>For our simulation, we still need to do a bit more – we haven&rsquo;t yet addressed the problem of how to update location and speed based on the elapsed real time. Let&rsquo;s talk about the approach for that next.</p><h2 id=frame-independent-movement-with-delta-timing-a-namemovementa>Frame-Independent Movement With Delta Timing <a name=movement></a></h2><p>When building game logic, we need to keep one essential point in mind: <strong>Not all frames are created equal!</strong></p><ul><li>On a 60 Hz display, each frame is visible for 16ms.</li><li>On a 120 Hz display, that number drops to 8.3ms.</li><li>On a 240 Hz display, each frame only shows for 4.2ms.</li><li>On a system under load, or while running in a non-focused window, the application frame rate may be lower than 60 Hz.</li></ul><p>That means that <strong>we can&rsquo;t use &ldquo;frames&rdquo; as a measurement of time</strong>: If we define the speed of our spaceship in relation to the frame rate, it would move four times faster on a 240 Hz display than on a 60 Hz display.</p><p><img src=/assets/asteroids-cfd2/vo8s3j8b4v0zx8b3eozn.png alt=frame-based></p><p>We need to <strong>decouple the game logic</strong> (and its rudimentary &ldquo;physics simulation&rdquo;) <strong>from the frame rate</strong> at which our application runs. Even <a href="https://youtu.be/qpC43CdvjyA?t=25">AAA games</a> don&rsquo;t get this right all the time – but for our projects, we can do better!</p><p>A straightforward approach for this decoupling is to use <a href=https://en.wikipedia.org/wiki/Delta_timing><strong>delta timing</strong></a>: We calculate the new game state based on the <em>time difference</em> (the <em>delta</em>) since the last time we updated the game.
This usually means we <em>multiply</em> the result of our calculations with the time delta, <em>scaling</em> the result based on the elapsed time.</p><p><img src=/assets/asteroids-cfd2/3dnr7776bas1ly70yjvr.png alt=time-based></p><p>In Compose for Desktop, we use <code>withFrameMillis</code> and <code>withFrameNanos</code>. Both of them provide a timestamp, so we just need to keep track of the previous timestamp to calculate the <code>delta</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>var</span> prevTime = <span style=color:#d3869b>0L</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>update</span>(time: Long) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> delta = time - prevTime
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// . . .
</span></span></span></code></pre></div><p>In my case, a <code>GameObject</code> has an <code>update</code> function that takes a <code>realDelta: Float</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> velocity = movementVector * realDelta.toDouble()
</span></span><span style=display:flex><span>obj.position <span style=color:#fe8019>+=</span> velocity
</span></span></code></pre></div><p>As demonstrated in the code above, I use it to scale the velocity of game objects.</p><h2 id=closing-thoughts>Closing Thoughts</h2><p>This concludes our tour of building a small game with Compose for Desktop! To see how all the pieces fit together, read the source code (~300 lines of code) on <a href=https://github.com/SebastianAigner/asteroids-compose-for-desktop><strong>GitHub</strong></a>!</p><p>Building Asteroids on Compose for Desktop was great fun! I am always surprised by the iteration speed that <a href=https://www.jetbrains.com/lp/compose/>Compose for Desktop</a> provides: <strong>Getting from a first rectangle to a full game in just one long evening.</strong></p><p>Of course, implementing a retro game like Asteroids on modern hardware comes with the luxury of not having to think too hard about performance optimizations, allocations, entity-component systems, or more. When building something more ambitious, these points likely need addressing, and you might find yourself using a few additional libraries besides a <code>Vector2</code> implementation.</p><p>For the next <a href=https://en.wikipedia.org/wiki/Super_Hexagon>Super Hexagon</a>, <a href=https://en.wikipedia.org/wiki/Roguelike>pixel roguelike</a>, or other 2D game, however, you can definitely <strong>give Compose a shot</strong>.</p><p>Once again, you can find all 300 lines of source code for this project on <a href=https://github.com/SebastianAigner/asteroids-compose-for-desktop><strong>GitHub</strong></a>.</p><p>If you&rsquo;re looking for additional inspiration, take a look at some other <strong>folks building games with Compose</strong>!</p><ul><li>Vivek Sharma built <a href=https://twitter.com/V9vek/status/1350156513625534464>everybody&rsquo;s favorite dinosaur game</a></li><li>vitaviva built <a href=https://twitter.com/vitaviva2/status/1379876842560122886>Tetris with Compose</a></li><li>John O&rsquo;Reilly made a <a href=https://github.com/joreilly/chip-8>Compose for Desktop CHIP-8 frontend</a></li><li>theapache64 pushes the limits of Compose&rsquo;s builtin components to implement <a href=https://twitter.com/theapache64/status/1379735815023030279>Switch, Check, and Radio Snake</a></li></ul><div><div>Tags:</div><ul><li><a href=/tags/gamedev/>gamedev</a></li><li><a href=/tags/kotlin/>kotlin</a></li><li><a href=/tags/jetpackcompose/>jetpackcompose</a></li><li><a href=/tags/android/>android</a></li></ul></div></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>