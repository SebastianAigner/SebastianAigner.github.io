<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta property="og:url" content="https://sebi.io/posts/2018-08-13-developing-for-raspberry-pi/"><meta property="og:site_name" content="Sebastian Aigner"><meta property="og:title" content="Developing for Raspberry Pi using IntelliJ Deployment"><meta property="og:description" content="So a few days ago I published the Thermal-Kotlin library which allows use of thermal printers in conjunction with a Raspberry Pi. That library and the way I developed it will get its own article soon, but I wanted to pick out one part that was particularily interesting for me: Automatic Deployment using IntelliJ.
When prototyping the library, I had to run it on the Raspberry Pi often, in order to figure out the exact workings of the protocol used by the printer and even try out timings that wouldn‚Äôt prevent the printer‚Äôs buffer from overflowing. At first I tried running IntelliJ on the Raspberry Pi to little success (unfortuantely the Pi isn‚Äôt nearly beefy enough to run a fully fledged IDE at a comfortable speed), but I didn‚Äôt want to miss out on all the great autocompletion and refactoring features that I have become so used to in IntelliJ."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-13T16:17:02+00:00"><meta property="article:modified_time" content="2018-08-13T16:17:02+00:00"><title>Developing for Raspberry Pi using IntelliJ Deployment | Sebastian Aigner</title>
<link rel=stylesheet href=https://sebi.io/sass/main.dff9443f6efd9e3e2cea841c40614da82c0c2621a4a955facffd4efbd46738bd.css integrity="sha256-3/lEP279nj4s6oQcQGFNqCwMJiGkqVX6z/1O+9RnOL0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Developing for Raspberry Pi using IntelliJ Deployment</h1><p class=post-meta><time class=dt-published datetime=2018-08-13T16:17:02+00:00>August 13, 2018</time></p></header><div class="post-content e-content"><p>So a few days ago I published the <a href=https://github.com/SebastianAigner/Thermal-Kotlin>Thermal-Kotlin</a> library which allows use of thermal printers in conjunction with a Raspberry Pi. That library and the way I developed it will get its own article soon, but I wanted to pick out one part that was particularily interesting for me: <strong>Automatic Deployment using IntelliJ</strong>.</p><p>When prototyping the library, I had to run it on the Raspberry Pi often, in order to figure out the exact workings of the protocol used by the printer and even try out timings that wouldn&rsquo;t prevent the printer&rsquo;s buffer from overflowing. At first I tried running IntelliJ on the Raspberry Pi to little success (unfortuantely the Pi isn&rsquo;t nearly beefy enough to run a fully fledged IDE at a comfortable speed), but I didn&rsquo;t want to miss out on all the great autocompletion and refactoring features that I have become so used to in IntelliJ.</p><p>So, I searched for a way to <strong>write code on my Macbook, and execute it on the Raspberry Pi</strong>. I quickly found that the <em>Deployment</em> functionality in IntelliJ IDEA Ultimate is the ideal way to achieve this.</p><blockquote><p>Remote Deployment is an IntelliJ IDEA Ultimate feature. If you&rsquo;re a student, check out <a href=https://www.jetbrains.com/student/>jetbrains.com/student</a> and grab a free Ultimate license! üë®üèª‚Äçüéì</p></blockquote><p>We will be using <em>Kotlin</em> and <em>Gradle</em> for the project. With a few adjustments, it should be no problem to get a similar setup with a different language of your choice!</p><p>I have used the Raspbian installation that comes with the NOOBS SD card. If you have a different operating system, some of the commands illustrated might differ slightly.</p><p>For the example, we will create a simple <code>Hello Pi</code> application that we will <strong>write completely on our workstation</strong>, and <strong>automatically deploy to our Raspberry Pi</strong> whenever we change code. <strong>This way, our test cycles become shorter and we can increase our productivity.</strong></p><h3 id=setting-up-the-kotlingradle-project-for-easy-execution>Setting up the Kotlin/Gradle Project for Easy Execution</h3><p>In order to make our lives a bit easier down the line, we create our project using <em>Gradle</em>. This means that we will be able to use the Gradle wrapper <code>gradlew</code> which will make life on the Pi easier for us. Since Kotlin is my favorite JVM language, I will also set it up accordingly.</p><p>We create the project as usual, giving it a <code>GroupId</code> and <code>ArtifactId</code> that is to our liking.</p><p><img src=/assets/remote_dev/project_creation.png alt=project_creation>As soon as you click finish, Gradle will start downloading all your dependencies.</p><p>Since our example doesn&rsquo;t focus on any application logic, but rather the configuration, we can simply create a small <code>Hello.kt</code> script in the <code>src/main/kotlin</code> directory so graciously provided by our IntelliJ.</p><p>Typing <code>psvm</code> (a handy shortcut for generating the <code>public static void main</code> from Java or its Kotlin equivalent <code>fun main</code>) and filling out the blanks with little creativity leaves us with:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>main</span>(args: Array&lt;String&gt;) {
</span></span><span style=display:flex><span>    println(<span style=color:#b8bb26>&#34;Hello Pi!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;and that already concludes the coding part of the tutorial! üòâ</p><p>We also want to tell Gradle that our <code>main</code> method should be called when we execute the <code>run</code> task in gradle. Thankfully, Gradle provides a plugin called <code>application</code> which makes this super easy. So, add to your <code>build.gradle</code> file the following snippet:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=display:flex><span>apply <span style=color:#fb4934>plugin:</span> <span style=color:#b8bb26>&#39;application&#39;</span>
</span></span><span style=display:flex><span>mainClassName <span style=color:#fe8019>=</span> <span style=color:#b8bb26>&#39;HelloKt&#39;</span>
</span></span></code></pre></div><p>This tells Gradle that the <code>run</code> task executes the application by invoking the main method from the (<a href=https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#package-level-functions>auto-generated</a>) <code>HelloKt</code> class stemming from the equally named <code>.kt</code> file.</p><p>Now that our project is ready to be run via Gradle, let&rsquo;s configure our IDE so that whenever a change is made to the local code, this change is automatically transferred to the device we actually would like to run it on, i.e. the Raspberry Pi.</p><h3 id=setting-up-automatic-deployment>Setting up Automatic Deployment</h3><p>Now that we have our local project set up and ready to go, it&rsquo;s time for us to configure IntelliJ so that changes to the files will be automatically synchronized with the files on the Raspberry Pi.</p><blockquote><p>It is important to check that you can connect via SSH to your Raspberry Pi, as otherwise none of the steps below will work. If you&rsquo;re not sure about how to set up SSH, consult the <a href=https://www.raspberrypi.org/documentation/remote-access/ssh/>official tutorials</a>.</p></blockquote><p>In order to automatically deploy to the Raspberry Pi, we set up a <em>Deployment Configuration</em> by selecting the corresponding menu item in the <code>Tools</code> bar.</p><p><img src=/assets/remote_dev/tools_deployment_configuration.png alt=tools_deployment_configuration></p><p>We click the <code>+</code> icon to generate a new configuration, give it an apt and ideally punny name, and choose <code>SFTP</code> as type:</p><p><img src=/assets/remote_dev/add_server.png alt=add_server></p><p>Set up the config as you would expect. You can set up a root path either by typing out what you want the path to be (though it should already exist on the target system), or click on the triple-dots (ideally after filling out the authenticiation section).</p><p>Before continuing the configuration for the mappings, hit the &lsquo;Test SFTP connection&rsquo; to make sure that stuff works well. Unless you&rsquo;re working with an actual webapp, you can ignore the <em>Web Server Root URL</em> part for now.</p><p><img src=/assets/remote_dev/deployment_config.png alt=deployment_config></p><p>If you have validated that your connection works fine, we can move on to the <em>Mappings</em> tab.</p><p>Now, due to the way the application is structured, we need three mappings. IntelliJ is rather helpful after filling out the most straightforward mapping:</p><p><img src=/assets/remote_dev/Deployment_Mapping.png alt=Deployment_Mapping></p><p>Press the little <em>Fix</em> button on the bottom to auto-generate the unmapped configurations, and fill them out in the most straightforward way imaginable:</p><p><img src=/assets/remote_dev/content_root_mapping.png alt=content_root_mapping></p><p>If you&rsquo;ve filled everything in correctly, you shouldn&rsquo;t see any warnings at the bottom of the page. And hey, that&rsquo;s actually the biggest part of the configuration done!</p><p>Hit &lsquo;OK&rsquo; and take a moment to celebrate your achievement.</p><h3 id=testing-deployment>Testing Deployment</h3><p>We can try out the magic we have just set up by right clicking the root of our project in the explorer and choosing <em>Deployment/Upload to&mldr;</em>.</p><p><img src=/assets/remote_dev/upload_to_berry.png alt=upload_to_berry></p><p>If everything has been done right, the in-application console will happily acknowledge success:</p><pre tabindex=0><code>[13/08/2018, 17:21] Upload to Himbeere
[13/08/2018, 17:21] Upload to Himbeere completed in less than a minute: 15 files transferred (232.8 kbit/s)
</code></pre><p>In case of an error (such as when the path you specified does not exist), we might be greeted with an error message like the one below.</p><pre tabindex=0><code>[13/08/2018, 17:20] Upload to Himbeere
[13/08/2018, 17:20] Upload to Himbeere failed: could not change to work directory &#34;/home/pi/Desktop/exampleProject&#34;. (No such file)
</code></pre><p>Changing the path or creating the path on the remote machine fixes this problem.</p><h3 id=automating-deployment>Automating Deployment</h3><p>Before we actually execute our application for the first time on the remote host, let&rsquo;s spare our right mouse button some hard work by automating the upload functionality. Navigate to the <em>Options</em> menu for the <em>Deployment</em> functionality:</p><p><img src=/assets/remote_dev/deployment_options.png alt=deployment_options></p><p>Feel free to adjust all of these options to your liking. We are especially looking at <em>Upload changed files automatically to the default server</em> right now. Either choose <em>Always</em> or <em>On explicit save action</em> depending on your preference:</p><p><img src=/assets/remote_dev/upload_changed_files.png alt=upload_changed_files></p><p>Hit the OK button to save your settings, perform a save action or change some code and watch IntelliJ automatically upload the changes.</p><h3 id=running-on-raspberry-pi>Running on Raspberry Pi</h3><p>Now let&rsquo;s get our application actually running on the Raspberry Pi. To do this, we go through a few quick steps in a terminal emulator of our choice.</p><ol><li>Connect to the Raspberry Pi using SSH: <code>ssh pi@himbeere</code></li><li>Navigate to your project folder: <code>cd ~/Desktop/exampleProject</code></li><li>List the output of the folder: <code>ls</code> ‚Äì you should be presented with the same files you see in IntelliJ on your development machine</li><li>Alllow <code>gradlew</code> to be an executable: <code>chmod +x ./gradlew</code></li><li>Execute our application: <code>./gradlew run</code>.</li></ol><p>The first startup can take a while, as <code>gradlew</code> downloads a gradle distribution and starts up a gradle daemon. Apart from a lot of download bars scrolling by, you should be greeted by your application running successfully!</p><p><img src=/assets/remote_dev/run_application.png alt=run_application></p><h3 id=conclusion>Conclusion</h3><p>We have seen that IntelliJ IDEA Ultimate&rsquo;s Deployment functionality is a great way to keep a project that you develop locally in sync with a (maybe less powered) host system that is connected via network. It serves as a useful tool when access to the other machine is cumbersome, or outright impossible (in the case of server, for example).</p><p>I hope that you&rsquo;re now well equipped to use the Deployment functionality in your next project!</p></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>