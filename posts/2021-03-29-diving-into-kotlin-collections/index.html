<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta property="og:url" content="https://sebi.io/posts/2021-03-29-diving-into-kotlin-collections/"><meta property="og:site_name" content="Sebastian Aigner"><meta property="og:title" content="Diving into Kotlin collections"><meta property="og:description" content="Kotlin's standard library provides awesome and versatile tools to manage groups of items. Let's take a closer look!"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-29T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-29T00:00:00+00:00"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Android"><meta property="article:tag" content="Productivity"><title>Diving into Kotlin collections | Sebastian Aigner</title>
<link rel=stylesheet href=https://sebi.io/sass/main.1062dd691b84b3ea042cce5aecb22abbae6d1a58288b48fbcb72443c8f1930dd.css integrity="sha256-EGLdaRuEs+oELM5a7LIqu65tGlgoi0j7y3JEPI8ZMN0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Diving into Kotlin collections</h1><p class=post-meta><time class=dt-published datetime=2021-03-29T00:00:00+00:00>March 29, 2021</time></p></header><div class="post-content e-content"><p>This blog post accompanies a video from our <strong>YouTube series</strong> which you can find on our <a href=https://kotl.in/video>Kotlin YouTube channel</a>, or <strong>watch here</strong> directly!</p><iframe width=560 height=315 src="https://www.youtube.com/embed/F8jj7e-_jFA?si=S6T19DAGNXhz-CyM" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p><a href=https://kotlinlang.org/docs/collections-overview.html>Kotlin Collections</a>! You‚Äôve heard of them, you‚Äôve used them ‚Äì so it makes sense to learn even more about them! Kotlin&rsquo;s standard library provides <strong>awesome tools to manage groups of items</strong>, and we‚Äôre going to take a closer look!</p><p>Let&rsquo;s see <strong>what types of collections</strong> the Kotlin standard library offers, and explore a <strong>common subset of operations</strong> that‚Äôs available for all of the collections you get in the standard library. Let‚Äôs get started.</p><p>In the Kotlin standard library, we have three big types of collections: <strong>Lists</strong>, <strong>Sets</strong>, and <strong>Maps</strong>. Just like many other parts of the standard library, these <strong>collections are available anywhere you can write Kotlin</strong>: on the JVM, but also in Kotlin/Native, Kotlin/JS, and common Kotlin code.</p><h2 id=lists>Lists</h2><p>Let‚Äôs start with the <strong>most popular candidate</strong> of a collection in Kotlin: a <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/><code>List</code></a>. To rehearse:</p><p>A list is a collection of <strong>ordered elements</strong>. That means that you can access the elements of a list using <strong>indices</strong> ‚Äì so you can say ‚Äúgive me the element at position two‚Äù. There‚Äôs also <strong>no constraints on duplicate elements</strong> in our list. We can just put in whatever elements we‚Äôd like. So, very few constraints on content, and maximum versatility in how we access the elements!</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> aList = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Apple&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Banana&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Cherry&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Apple&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>aList <span style=color:#928374;font-style:italic>// [Apple, Banana, Cherry, Apple]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>aList[<span style=color:#d3869b>2</span>] <span style=color:#928374;font-style:italic>// Banana
</span></span></span></code></pre></div><h2 id=sets>Sets</h2><p>Next up, we have the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/><code>Set</code></a>! Sets are groups of objects where we don‚Äôt care about the order of elements. Instead, we want to make sure that our collection <strong>never contains any duplicates</strong>.</p><p>That‚Äôs the key property of a set: all of its <strong>contents are unique</strong>.</p><p>That makes sets a bit more of a specialized data structure, but there‚Äôs a good chance you want to use them in everyday scenarios anyway.</p><p>What are <strong>typical things</strong> you might want to store in a set? Tags, for example. Or, maybe you‚Äôre building a social network, and you want to store the IDs of all the friends that a certain user has. In both cases, you don&rsquo;t want to have duplicates in these collections, and probably don&rsquo;t care about the order.</p><p>A set can help you <strong>enforce these constraints</strong> without having to really think about it, and <strong>without manual duplication checks</strong>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> emotions = setOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Happy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Curious&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Joyful&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Happy&#34;</span>, <span style=color:#928374;font-style:italic>// even if we try to add duplicates...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#b8bb26>&#34;Joyful&#34;</span> <span style=color:#928374;font-style:italic>// ...to our set...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(emotions) <span style=color:#928374;font-style:italic>// ...the elements in our set stay unique!
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Happy, Curious, Joyful]
</span></span></span></code></pre></div><p>Sets are actually also a <strong>common mathematical abstraction</strong>. Typical mathematical concepts, like <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/union.html>unions</a>, <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/intersect.html>intersections</a>, or the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/subtract.html>set difference</a> also translate neatly into Kotlin code.</p><h2 id=maps>Maps</h2><p>Last, but certainly not least, we have <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/><code>Map</code></a>. A map is a <strong>set of key-value pairs</strong>, where <strong>each key is unique</strong>. It‚Äôs also sometimes called a ‚Äúdictionary‚Äù for that reason. You encounter maps whenever you‚Äôre <strong>associating data</strong> ‚Äì storing a persons name and their favorite pizza topping, or associating a license plate with vehicle information.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> peopleToPizzaToppings = mapOf(
</span></span><span style=display:flex><span>   <span style=color:#b8bb26>&#34;Ken&#34;</span> to <span style=color:#b8bb26>&#34;Pineapple&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:#b8bb26>&#34;Lou&#34;</span> to <span style=color:#b8bb26>&#34;Peperoni&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:#b8bb26>&#34;Ash&#34;</span> to <span style=color:#b8bb26>&#34;Ketchup&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(peopleToPizzaToppings)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// {Ken=Pineapple, Lou=Peperoni, Ash=Ketchup}
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>println(toppings[<span style=color:#b8bb26>&#34;Ash&#34;</span>])
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Ketchup
</span></span></span></code></pre></div><p>Key-value pairs are everywhere, and just like in many other languages, maps are the go-to way to manage them in Kotlin.</p><h2 id=collections-can-be-mutable>Collections can be mutable</h2><p>By default, these collections in Kotlin are <strong>read-only</strong>. This is in the spirit of <strong>immutability</strong> which accompanies typical functional paradigms ‚Äì instead of changing the contents of a collection, you create a new collection with the changes applied, which you can then <strong>safely pass around</strong> in your application, ensuring that the <strong>original collection stays unchanged</strong>.</p><p><img src=/assets/stdlib-collections/3avccfflc4ugw7l0xykt.png alt=image></p><p>But we also have <strong>mutable flavors</strong> of all of the collections in Kotlin: we have <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/><code>MutableList</code></a>, <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/><code>MutableSet</code></a>, and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/><code>MutableMap</code></a>. Those are modifiable, meaning you can <strong>comfortably add and remove elements</strong>. With data where you‚Äôre inherently expecting change, you‚Äôd probably use these mutable variants.</p><h2 id=collections-are-iterable>Collections are iterable</h2><p>Kotlin collections being <em>iterable</em> means that the standard library provides a <strong>common, standardized set of typical operations for collections</strong>, for example, to retrieve their size, check if they contain a certain item, and more.</p><p>Lists and sets directly implement the Collection interface, which in turn implements the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/><code>Iterable</code></a> interface. Maps have an <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/iterator.html><code>iterator()</code></a> operator function, and provide iterable properties, like their set of keys, their list of values, as well as the entries of the map, so key-value pairs.</p><p><img src=/assets/stdlib-collections/h7j7a868lyz9dowlwnrn.png alt=image></p><p>Let‚Äôs learn about some <strong>shared functionality of iterables</strong>. The following examples are going to use a list, but really, we can just assume that we‚Äôre just working with an <code>Iterable</code> here ‚Äì the concrete implementation does not matter. Also, all the functions discussed <strong>leave the original collection unchanged</strong>.</p><h2 id=looping-over-collections>Looping over collections</h2><p>A core function of an <code>Iterable</code>, as its name suggests, is that it provides a mechanism to <strong>access the elements</strong> that our collection contains, one after the other ‚Äì to iterate it.</p><p>The easiest way to go through all the elements in a collection is the basic Kotlin <a href=https://kotlinlang.org/docs/control-flow.html#for-loops><code>for</code></a> loop. When we use the <code>for</code> loop with an <code>Iterable</code>, the <code>in</code> operator cleverly understands that we want to <strong>go over the iterator</strong>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> fruits = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Apple&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Banana&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Cherry&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>for</span>(fruit <span style=color:#fe8019>in</span> fruits) {
</span></span><span style=display:flex><span>    println(fruit)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Apple
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Banana
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Cherry
</span></span></span></code></pre></div><p>In a <strong>more functional style</strong>, we can also write this same snippet using the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/for-each.html><code>forEach</code></a> function:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>fruits.forEach { fruit <span style=color:#fe8019>-&gt;</span>
</span></span><span style=display:flex><span>    println(fruit)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Apple
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Banana
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Cherry
</span></span></span></code></pre></div><p>In this case, <code>forEach</code> takes every element from our collection, and <strong>calls a function</strong> (which we provide) with the element as its argument.</p><h2 id=transforming-collections-map>Transforming collections: map</h2><p>Let&rsquo;s continue with a classic when it comes to <strong>transforming collections</strong>: the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html><code>map</code></a> function! (Don‚Äôt be confused! The <code>map</code> function has nothing to do with the <code>Map</code> collection type. You can treat them as two completely different things.)</p><p>Just like the <code>forEach</code> function, the <code>map</code> function is of <a href=https://kotlinlang.org/docs/lambdas.html>higher order</a>. So, it:</p><ul><li><strong>Takes each element</strong> from our collection,</li><li><strong>applies a function</strong> to it, and</li><li><strong>creates another collection</strong>, containing the return values of those function applications.</li></ul><p>The result of the map function doesn‚Äôt have to be the same type as the one of our input collection, either.</p><p>This makes the <code>map</code> function <strong>very versatile</strong> ‚Äì whether you want to parse a collection of strings into a collection of integers, or resolve a list of user names to a list of full user profiles ‚Äì‚Äì if you‚Äôre <strong>transforming one collection into another</strong>, it‚Äôs probably a good <strong>first instinct</strong> to think <code>map</code>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> fruits = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Apple&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Banana&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Cherry&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> stiurf = fruits.map {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.reversed()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, you might have a transformation inside your <code>map</code> function where you <strong>can‚Äôt generate valid results</strong> for all input elements. In this case, we can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-not-null.html><code>mapNotNull</code></a> function, and our resulting collection will only contain those function results that <strong>evaluated to an actual value</strong>. This also ensures that type of our resulting variable is <strong>non-nullable</strong>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> strs = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;2&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;three&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;4&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;V&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> nums: List&lt;Int&gt; = strs.mapNotNull {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.toIntOrNull()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(nums)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [1, 2, 4] 
</span></span></span></code></pre></div><p>If we need to <strong>keep track of the index</strong> of the element which we‚Äôre currently transforming, we can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-indexed.html><code>mapIndexed</code></a> function. It‚Äôs quite similar in how it works, but in this case, we get <strong>two parameters in our transformation function</strong>: the <em>index</em> and the <em>value</em>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> rank = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Gold&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Silver&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Bronze&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> ranking = rank.mapIndexed { idx, m <span style=color:#fe8019>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>$m</span><span style=color:#b8bb26> (</span><span style=color:#b8bb26>$idx</span><span style=color:#b8bb26>)&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(ranking)
</span></span><span style=display:flex><span><span style=color:#b8bb26;font-weight:700>[Gold (0), Silver (1), Bronze (2)]</span>
</span></span></code></pre></div><h2 id=filtering-collections-filter-and-partition>Filtering collections: filter and partition</h2><p>If we have a collection, but we‚Äôre only interested in <strong>elements that fulfil a certain condition</strong>, the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter.html><code>filter</code></a> function comes to the rescue!</p><p>Just like the previous examples, <code>filter</code> accepts <strong>another function as its parameter</strong>. This time, instead of defining a transformation, we‚Äôre defining what you can call a <strong>predicate</strong> here.</p><p>A predicate is a function that takes a collection element and <strong>returns a boolean value</strong>: <code>true</code> means that the given element matches the predicate, <code>false</code> means the opposite. So this predicate acts as the ‚Äú<strong>doorman</strong>‚Äù ‚Äì if the value is <code>true</code>, the collection item is let through to the result collection, otherwise, it is discarded.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>open</span> <span style=color:#fe8019>class</span> Person(<span style=color:#fe8019>val</span> name: String, <span style=color:#fe8019>val</span> age: Int) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>override</span> <span style=color:#fe8019>fun</span> <span style=color:#fabd2f>toString</span>() = name
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>class</span> Cyborg(name: String) : Person(name, <span style=color:#d3869b>99</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> people = listOf(
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Joe&#34;</span>, <span style=color:#d3869b>15</span>),
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Agatha&#34;</span>, <span style=color:#d3869b>25</span>),
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Amber&#34;</span>, <span style=color:#d3869b>19</span>),
</span></span><span style=display:flex><span>    Cyborg(<span style=color:#b8bb26>&#34;Rob&#34;</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> discoVisitors = people.filter {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.age <span style=color:#fe8019>&gt;=</span> <span style=color:#d3869b>18</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(discoVisitors)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Agatha, Amber, Rob]
</span></span></span></code></pre></div><p>If you‚Äôre testing a <strong>negative condition</strong>, you can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-not.html><code>filterNot</code></a> function instead, which behaves identically, but <strong>inverts the condition</strong>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> students = people.filterNot {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.age <span style=color:#fe8019>&gt;=</span> <span style=color:#d3869b>18</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(students)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Joe]
</span></span></span></code></pre></div><p>Note that both <code>filter</code> and <code>filterNot</code> <strong>discard elements</strong> where the condition doesn‚Äôt match. But maybe we don‚Äôt want to discard the ‚Äúother half‚Äù of elements, and instead we want to put those into a separate list. This is where the <code>partition</code> function comes into play.</p><p>By using <code>partition</code>, we <strong>combine the powers</strong> of <code>filter</code> and <code>filterNot</code>. It returns a <strong>pair of lists</strong>, where the first list contains all the elements for which the predicate holds true, and the second contains all the elements that fail the test. So, in our doorman analogy, instead of sending people who fail the check away, we just send them to a different place. (Using parentheses, we can <strong>destructure</strong> this pair of lists directly into two independent variables.)</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> (adults, children) = people.partition {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.age <span style=color:#fe8019>&gt;=</span> <span style=color:#d3869b>18</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(adults)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Agatha, Amber, Rob]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>println(children)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Joe]
</span></span></span></code></pre></div><p>If you‚Äôre bringing a <strong>collection of nullable items</strong> to the party, you can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-not-null.html><code>filterNotNull</code></a> function which, as you may have guessed, <strong>automatically discards any elements that are <code>null</code></strong>, and gives you a new collection with an adjusted, non-nullable type accordingly.</p><p>Speaking of adjusting types ‚Äì if your collection contains multiple elements from a type hierarchy, but you‚Äôre only interested in <strong>elements of a specific type</strong>, you can use <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-is-instance.html><code>filterIsInstance</code></a>, and specify the desired type as a generic parameter.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> people = listOf(
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Joe&#34;</span>, <span style=color:#d3869b>15</span>),
</span></span><span style=display:flex><span>    <span style=color:#fe8019>null</span>,
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Agatha&#34;</span>, <span style=color:#d3869b>25</span>),
</span></span><span style=display:flex><span>    <span style=color:#fe8019>null</span>,
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Amber&#34;</span>, <span style=color:#d3869b>19</span>),
</span></span><span style=display:flex><span>    Cyborg(<span style=color:#b8bb26>&#34;Rob&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#fe8019>null</span>,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> actualPeople = people.filterNotNull()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(actualPeople)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Joe, Agatha, Amber, Rob]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> cyborgs = people.filterIsInstance&lt;Cyborg&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(cyborgs)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [Rob]
</span></span></span></code></pre></div><h2 id=retrieve-collection-parts-take-and-drop>Retrieve collection parts: take and drop</h2><p>Filtering allowed us to apply a predicate function, and create a new collection containing items that match. But what about the even simpler cases? Sometimes, we just want to <strong>grab a few elements</strong> from our collection.</p><p>For that, we have the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take.html><code>take</code></a> and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop.html><code>drop</code></a> functions. You might already be able to guess what they do. <code>take</code> gives you a <strong>collection of the first n elements</strong> from your original collection. So <code>take(2)</code> is going to give you the first two elements. On the opposite hand, <code>drop(3)</code> is going to <strong>leave out the first three elements</strong> of your original collection, and only gives you everything that follows after those three elements. And you don‚Äôt have to be afraid to ‚Äúoverdrop‚Äù either ‚Äì dropping more elements from a collection than it contains just gives you an empty list:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> objects = listOf(<span style=color:#b8bb26>&#34;üå±&#34;</span>, <span style=color:#b8bb26>&#34;üöÄ&#34;</span>, <span style=color:#b8bb26>&#34;üí°&#34;</span>, <span style=color:#b8bb26>&#34;üêß&#34;</span>, <span style=color:#b8bb26>&#34;‚öôÔ∏è&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> seedlingAndRocket = objects.take(<span style=color:#d3869b>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(seedlingAndRocket)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [üå±, üöÄ]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> penguinAndGear = objects.drop(<span style=color:#d3869b>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(penguinAndGear)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [üêß, ‚öôÔ∏è]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> nothing = objects.drop(<span style=color:#d3869b>8</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(nothing)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// []
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>println(objects) <span style=color:#928374;font-style:italic>// remember, the original collection is not modified!
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [üå±, üöÄ, üí°, üêß, ‚öôÔ∏è]
</span></span></span></code></pre></div><p>One huge benefit of the functions we‚Äôve seen so far is their <strong>composability</strong>: Because mapping, filtering, taking, dropping, and all their friends return a new collection, it‚Äôs easy to just take that result, and <strong>immediately use it as an argument for the next collection function</strong>, turning collection into collection into collection.</p><p>However, we should keep in mind that chaining a number of these functions together means we generate a bunch of <strong>intermediate collections</strong>. Now, this isn‚Äôt going to set your computer on fire immediately, but it is still something to be aware of, especially when you work with very large collections. For this case, Kotlin has a few aces up its sleeve as well, called <a href=https://kotlinlang.org/docs/sequences.html>sequences</a>, but we will dive into those at a later point.</p><h2 id=aggregating-collections-sums-averages-minimums-maximums-and-counting>Aggregating collections: sums, averages, minimums, maximums, and counting</h2><p>Once we‚Äôre done transforming our data, we might want to get a <strong>single result value</strong> out of it. If we have a collection of <strong>numerical values</strong> like integers or doubles, we get some nice functions called <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/average.html><code>average</code></a> and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum.html><code>sum</code></a> out of the box, which help us calculate those values.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> randomNumbers = listOf(<span style=color:#d3869b>3</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>4</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>9</span>, <span style=color:#d3869b>2</span>, <span style=color:#d3869b>6</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>3</span>, <span style=color:#d3869b>6</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(randomNumbers.average())
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 4.09090909090909091
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>println(randomNumbers.sum())
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 45
</span></span></span></code></pre></div><p>In some situations (&mldr;or, we might say, <em>sum</em> situations&mldr;), we have a collection of more <strong>complex objects</strong>, and want to still <strong>add them up</strong> somehow, based on their properties. Of course, we could first use the <code>map</code> function to obtain a collection containing only numbers ‚Äì but by using the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum-of.html><code>sumOf</code></a> function, we can do all of this in a single function call: we can pass a function that acts as a <strong>selector</strong> (so a function that gives us whatever number we want to associate with the element) and <code>sumOf</code> will use the <strong>result of that selector function</strong> to <strong>add up</strong> all our elements.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> randomNames = listOf(<span style=color:#b8bb26>&#34;Dallas&#34;</span>, <span style=color:#b8bb26>&#34;Kane&#34;</span>, <span style=color:#b8bb26>&#34;Ripley&#34;</span>, <span style=color:#b8bb26>&#34;Lambert&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> cumulativeLength = randomNames.sumOf { <span style=color:#fe8019>it</span>.length }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(cumulativeLength)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 23
</span></span></span></code></pre></div><p>If we‚Äôre only interested in the <strong>greatest or smallest value</strong> contained in our collection of numbers, we can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/max-or-null.html><code>maxOrNull</code></a> and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/min-or-null.html><code>minOrNull</code></a> functions.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(randomNumbers.minOrNull())
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 9
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>println(randomNumbers.maxOrNull())
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 1
</span></span></span></code></pre></div><p>And just like <code>sumBy</code>, we have the sibling functions <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/max-of.html><code>maxOf</code></a> and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/min-of.html><code>minOf</code></a>, where we once again pass a <strong>selector function</strong>, which is going to be used to <strong>determine the maximum or minimum</strong> of a collection.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> longestName = randomNames.maxOf { <span style=color:#fe8019>it</span>.length }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(longestName)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 7
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> shortestName = randomNames.minOf { <span style=color:#fe8019>it</span>.length }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(shortestName)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 4
</span></span></span></code></pre></div><p>If we just care about the <strong>number of elements</strong> contained in our collection, we can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/count.html><code>count</code></a> function ‚Äì either without any parameters, to just get the number of all elements, or using a <strong>predicate</strong>. So that‚Äôs like filtering the collection first, and then counting the elements. But again, all wrapped into one.</p><pre tabindex=0><code>val digits = randomNumbers.count()

println(digits)
// 11

val bigDigits = randomNumbers.count { it &gt; 5 }

println(bigDigits)
// 3
</code></pre><p>There‚Äôs also the powerful <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html><code>joinToString</code></a> function, which allows us to <strong>turn all elements of our collection into a string</strong>, complete with a metric ton of customization options like separators, prefixes and postfixes, limits or a placeholder if you have more elements than what your specified limit allows. And even <code>joinToString</code> accepts a <strong>transformation function</strong>, once again, so you don‚Äôt need to do some kind of separate mapping beforehand, it‚Äôs all built in. Truly powerful stuff to create a string from a collection.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> str = randomNumbers.joinToString (
</span></span><span style=display:flex><span>    separator = <span style=color:#b8bb26>&#34;-&#34;</span>,
</span></span><span style=display:flex><span>    prefix = <span style=color:#b8bb26>&#34;pi://&#34;</span>,
</span></span><span style=display:flex><span>    limit = <span style=color:#d3869b>5</span>
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;[</span><span style=color:#b8bb26>$it</span><span style=color:#b8bb26>]&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(str)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// pi://[3]-[1]-[4]-[1]-[5]-...
</span></span></span></code></pre></div><p>That&rsquo;s it &ndash; have a nice Kotlin!</p><div><div>Tags:</div><ul><li><a href=/tags/kotlin/>Kotlin</a></li><li><a href=/tags/programming/>Programming</a></li><li><a href=/tags/android/>Android</a></li><li><a href=/tags/productivity/>Productivity</a></li></ul></div></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>