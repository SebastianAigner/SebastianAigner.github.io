<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta property="og:title" content="Generating thumbnails 3.8x faster by using ffmpeg seeking instead of fps filtering"><meta property="og:description" content="As part of tinkering with reelchest, one of the tasks I need to tackle is thumbnail generation.
A few ways to do that are described in the official ffmpeg documentation. Since I want to create more than one thumbnail per media file (hopefully, so that I can do some kind of cool crossfade effect that makes the entire application feel a bit more lively), I opted for the fps video filter."><meta property="og:type" content="article"><meta property="og:url" content="https://sebi.io/posts/2024-12-21-faster-thumbnail-generation-with-ffmpeg-seeking/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-21T00:00:01+00:00"><meta property="article:modified_time" content="2024-12-21T00:00:01+00:00"><title>Generating thumbnails 3.8x faster by using ffmpeg seeking instead of fps filtering | Sebastian Aigner</title><link rel=stylesheet href=https://sebi.io/sass/main.1062dd691b84b3ea042cce5aecb22abbae6d1a58288b48fbcb72443c8f1930dd.css integrity="sha256-EGLdaRuEs+oELM5a7LIqu65tGlgoi0j7y3JEPI8ZMN0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Generating thumbnails 3.8x faster by using ffmpeg seeking instead of fps filtering</h1><p class=post-meta><time class=dt-published datetime=2024-12-21T00:00:01+00:00>December 21, 2024</time></p></header><div class="post-content e-content"><p>As part of tinkering with <a href=https://github.com/SebastianAigner/reelchest>reelchest</a>, one of the tasks I need to tackle is thumbnail generation.</p><p>A few ways to do that are described in the official <a href=https://trac.ffmpeg.org/wiki/Create%20a%20thumbnail%20image%20every%20X%20seconds%20of%20the%20video>ffmpeg documentation</a>. Since I want to create more than one thumbnail per media file (hopefully, so that I can do some kind of cool crossfade effect that makes the entire application feel a bit more lively), I opted for the <code>fps</code> video filter. Here&rsquo;s the snippet in my code that creates a thumbnail every 10 seconds into the video. (The snippet here is Kotlin, but they&rsquo;re the literal CLI flags passed to the <code>ffmpeg</code> process, so this should be comprehensible.)</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> task = FfmpegTask(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;-y&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;-i&#34;</span>,
</span></span><span style=display:flex><span>    videoFile.name,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;-q:v&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;5&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;-vf&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;fps=1/10&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;thumb%04d.jpg&#34;</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>This process takes 10.34s for my example input file (a ~4-minute-long vacation video) on an M2 Max. That feels <em>slow</em>. Since I intend <code>reelchest</code> to also work decently on low-powered devices like a Raspberry Pi, there&rsquo;s a simple question that pops up here: <strong>Can we go faster?</strong></p><p>As it turns out, we can.</p><h2 id=time-to-seek-in-a-fast-manner>Time to seek in a fast manner</h2><p>The reason why this approach is slow is that it essentially decodes the entire video and spits out a new, filtered &ldquo;video&rdquo; with the framerate of &ldquo;one frame every 10 seconds&rdquo;. Instead of creating one combined video file, it instead exports the frames of that new video as individual images, and tada, we have our thumbnails.</p><p>However, <strong>this requires the entire video to be decoded, even though we only look at a single frame every 10 seconds!</strong> That&rsquo;s pretty wasteful, and especially noticeable on e.g. a Raspberry Pi, where this process will happily saturate all CPU cores for a few minutes per input video.</p><p>So, what&rsquo;s a better way of extracting these frames, then? The answer is <em>seeking</em>: jumping to each relevant timestamp and extracting the frame then-and-there. A seeking-based solution is actually the first one on the <a href=https://trac.ffmpeg.org/wiki/Create%20a%20thumbnail%20image%20every%20X%20seconds%20of%20the%20video>ffmpeg wiki</a>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ffmpeg -i input.flv -ss 00:00:14.435 -frames:v <span style=color:#d3869b>1</span> out.png
</span></span></code></pre></div><p>However, this is described as &ldquo;Output a single frame from the video into an image file&rdquo; &ndash; not what we want! However, with a bit of craftiness, we can twist this solution into something that does work for our use case. Here&rsquo;s the game plan:</p><ul><li>Figure out the length of the video</li><li>Programmatically craft one seek command per timestamp every ten seconds</li><li>Join all of them together as one mega-<code>ffmpeg</code> incantation.</li></ul><p>First, we need to figure out how many thumbnails we can actually generate. We do that by figuring out how long our video is. Enter <a href=https://ffmpeg.org/ffprobe.html><code>ffprobe</code></a>, sibling to <code>ffmpeg</code> and designed to &ldquo;gather information from multimedia streams&rdquo;. Duration is one of those pieces of information! Here&rsquo;s how I extract the duration &ndash; again in Kotlin, but the CLI arguments continue to be language-independent:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> durationRegex = <span style=color:#b8bb26>&#34;&#34;&#34;(\d+\.?\d*)&#34;&#34;&#34;</span>.toRegex()
</span></span><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>getVideoDuration</span>(inputFile: File): Duration {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> lines = ProcessBuilder(
</span></span><span style=display:flex><span>        <span style=color:#b8bb26>&#34;ffprobe&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#b8bb26>&#34;-v&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#b8bb26>&#34;quiet&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#b8bb26>&#34;-print_format&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#b8bb26>&#34;json=c=1&#34;</span>, <span style=color:#928374;font-style:italic>// I don&#39;t know why the output isn&#39;t compacted even though I&#39;m passing c=1, but we&#39;ll move along
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>        <span style=color:#b8bb26>&#34;-show_entries&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#b8bb26>&#34;format=duration&#34;</span>,
</span></span><span style=display:flex><span>        inputFile.absolutePath
</span></span><span style=display:flex><span>    ).start().inputStream.bufferedReader().readText()
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> (durationStr) = durationRegex.find(lines)<span style=color:#fe8019>?.</span>destructured
</span></span><span style=display:flex><span>        <span style=color:#fe8019>?:</span> error(<span style=color:#b8bb26>&#34;ffprobe on </span><span style=color:#b8bb26>$inputFile</span><span style=color:#b8bb26> didn&#39;t return a duration&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> durationStr.toDouble().seconds
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With the video duration in our hands, we can now move on to crafting the mega-<code>ffmpeg</code> incantation. There&rsquo;s a few things that we want to pay attention to here:</p><p>Firstly, we really want to make sure we specify the seek flag <code>-ss</code> before the input flag <code>-i</code>! That&rsquo;s because we want to do <em>input seeking</em>: Parsing the input by keyframe, <a href=https://trac.ffmpeg.org/wiki/Seeking>which is very fast</a>. Weirdly enough, this isn&rsquo;t used by the <a href=https://trac.ffmpeg.org/wiki/Create%20a%20thumbnail%20image%20every%20X%20seconds%20of%20the%20video>thumbnail wiki entry</a>.</p><p>Secondly, we&rsquo;ll create a large command that will look like this:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ffmpeg -y -ss <span style=color:#d3869b>65</span> -i invideo.mp4 -q:v <span style=color:#d3869b>5</span> -frames:v <span style=color:#d3869b>1</span> -map 0:v:0 out.jpg <span style=color:#b8bb26>\
</span></span></span><span style=display:flex><span><span style=color:#b8bb26></span> -ss 00:00:20.0 -i invideo.mp4 -q:v <span style=color:#d3869b>5</span> -frames:v <span style=color:#d3869b>1</span> -map 1:v:0 out2.jpg
</span></span></code></pre></div><p>Since we do <em>input seeking</em>, we need to specify the video we&rsquo;re operating on for each invocation (note <code>invideo.mp4</code> is present in both lines). It also means that when we get out the images, we need to make sure we refer to the correct input source &ndash; in the second line, we want to access the <em>first video stream in the second file (0-indexed, so with ID 1)</em>, which is expressed by <code>1:v:0</code>.</p><p>We can now craft our list of ffmpeg arguments by creating one set of arguments of shape <code>-ss 00:00:20.0 -i invideo.mp4 -q:v 5 -frames:v 1 -map 1:v:0 out2.jpg</code> per line. Here&rsquo;s how I do that in Kotlin:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> dur = getVideoDuration(videoFile)
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> ffmpegParameters = buildList&lt;String&gt; {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>var</span> streamId = <span style=color:#d3869b>0</span>
</span></span><span style=display:flex><span>    add(<span style=color:#b8bb26>&#34;-y&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>for</span> (timestamp <span style=color:#fe8019>in</span> <span style=color:#d3869b>0.</span>.dur.inWholeSeconds step <span style=color:#d3869b>10</span>) {
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;-ss&#34;</span>)
</span></span><span style=display:flex><span>        add(timestamp.toString())
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;-i&#34;</span>)
</span></span><span style=display:flex><span>        add(videoFile.absolutePath)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;-q:v&#34;</span>)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;5&#34;</span>)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;-frames:v&#34;</span>)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;-map&#34;</span>)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>$streamId</span><span style=color:#b8bb26>:v:0&#34;</span>)
</span></span><span style=display:flex><span>        add(<span style=color:#b8bb26>&#34;out</span><span style=color:#b8bb26>$streamId</span><span style=color:#b8bb26>.jpg&#34;</span>)
</span></span><span style=display:flex><span>        streamId<span style=color:#fe8019>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this new approach, the generation now takes 2.68s &ndash; <strong>that&rsquo;s a cool 3.8x improvement</strong> over <code>fps</code>-filtering the entire video!</p><p>A <em>slightly</em> less involved version of this would be to spawn one <code>ffmpeg</code> process per 10-second segment, but since I&rsquo;m already programmatically crafting the CLI arguments anyway, I don&rsquo;t see a reason to take that detour at this point &ndash; if you see one, let me know. Happy thumbnailing!</p></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>