<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Idiomatic Kotlin: Solving Advent of Code Puzzles, Passport Validation | Sebastian Aigner</title><link rel=stylesheet href=https://sebi.io/sass/main.1062dd691b84b3ea042cce5aecb22abbae6d1a58288b48fbcb72443c8f1930dd.css integrity="sha256-EGLdaRuEs+oELM5a7LIqu65tGlgoi0j7y3JEPI8ZMN0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Idiomatic Kotlin: Solving Advent of Code Puzzles, Passport Validation</h1><p class=post-meta><time class=dt-published datetime=2021-09-01T00:00:00+00:00>September 1, 2021</time></p></header><div class="post-content e-content"><p>Today in “Idiomatic Kotlin”, we’re looking at <a href=https://adventofcode.com/2020/day/4>day 4 of the Advent of Code 2020 challenges</a>, in which we tackle a problem that feels as old as programming itself: input sanitization and validation.</p><iframe width=560 height=315 src="https://www.youtube.com/embed/-kltG4Ztv1s?si=qzN8HpNJOgM0Ih47" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h2 id=day-4-passport-processing>Day 4. Passport processing</h2><p>We need to build a passport scanner that, given a batch of input text, can count how many passports are <em>valid.</em> You can find the complete task description at <a href=https://adventofcode.com/2020/day/4*>https://adventofcode.com/2020/day/4</a>.</p><p>Like many challenges, we first inspect our input:</p><pre tabindex=0><code>ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm

iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884
hcl:#cfa07d byr:1929

hcl:#ae17e1 iyr:2013
eyr:2024
ecl:brn pid:760753108 byr:1931
hgt:179cm
</code></pre><p>The input is a batch of travel documents in a text file, separated by blank lines. Each <em>passport</em> is represented as a sequence of key-colon-value pairs separated by spaces or newlines. <em>Our</em> challenge is finding out how many passports are valid. For part one, “valid” means that they need to have all the required fields outlined by the security personnel: <code>byr</code>, <code>iyr</code>, <code>eyr</code>, <code>hgt</code>, <code>hcl</code>, <code>ecl</code> and <code>pid</code> (we conveniently ignore their request to validate the <code>cid</code> field).</p><h2 id=solving-day-4-part-1>Solving Day 4, Part 1</h2><p>Like many challenges, we start by reading our puzzle input as text and trim off any extraneous whitespace at the beginning and the end of the file. As per the description, passports are always separated by blank lines. A blank line is just two “returns”, or newlines, in a row, so we’ll use this to split our input string into the individual passports:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> passports = File(<span style=color:#b8bb26>&#34;src/day04/input.txt&#34;</span>)
</span></span><span style=display:flex><span>    .readText()
</span></span><span style=display:flex><span>    .trim()
</span></span><span style=display:flex><span>    .split(<span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\n\n</span><span style=color:#b8bb26>&#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\r\n\r\n</span><span style=color:#b8bb26>&#34;</span>)
</span></span></code></pre></div><p>(Note that depending on your operating system, the line separator in text files is different: On Windows, it is <code>\r\n</code>, on Linux and macOS, it’s <code>\n</code>. Kotlin’s <code>split</code> method takes an arbitrary number of delimiters, allowing us to cover both cases directly.)</p><p>We now have a list of passport strings. However, working with lists of raw strings can quickly get confusing. Let’s use Kotlin’s expressive type system to improve the situation and encapsulate the string in a very basic <code>Passport</code> class.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>class</span> Passport(<span style=color:#fe8019>private</span> <span style=color:#fe8019>val</span> text: String) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We then just map the results of our split-up input to <code>Passport</code> objects:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#928374;font-style:italic>// . . .
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>.map { Passport(<span style=color:#fe8019>it</span>) }
</span></span></code></pre></div><p>From the problem description, we remember that key-value pairs are either separated by spaces or newlines within a single passport. Therefore, to get the individual pairs, we once again split our input. The delimiters, in this case, are either a space or one of the newline sequences.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>hasAllRequiredFields</span>(): Boolean {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> fieldsWithValues = text.split(<span style=color:#b8bb26>&#34; &#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\r\n</span><span style=color:#b8bb26>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We then extract the key from each passport entry. We can do so by mapping our combined <code>fieldsWithValues</code> to <em>only</em> the substring that comes before the colon:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>hasAllRequiredFields</span>(): Boolean {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> fieldsWithValues = text.split(<span style=color:#b8bb26>&#34; &#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\r\n</span><span style=color:#b8bb26>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> fieldNames = fieldsWithValues.map { <span style=color:#fe8019>it</span>.substringBefore(<span style=color:#b8bb26>&#34;:&#34;</span>) }
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> fieldNames.containsAll(requiredFields)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The result of our function will be whether the <code>fieldNames</code> we extracted contain all required fields. The <code>requiredFields</code> collection can be taken directly from the problem statement and translated into a list:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>private</span> <span style=color:#fe8019>val</span> requiredFields = listOf(<span style=color:#b8bb26>&#34;byr&#34;</span>, <span style=color:#b8bb26>&#34;iyr&#34;</span>, <span style=color:#b8bb26>&#34;eyr&#34;</span>, <span style=color:#b8bb26>&#34;hgt&#34;</span>, <span style=color:#b8bb26>&#34;hcl&#34;</span>, <span style=color:#b8bb26>&#34;ecl&#34;</span>, <span style=color:#b8bb26>&#34;pid&#34;</span> <span style=color:#928374;font-style:italic>/*&#34;cid&#34;*/</span>)
</span></span></code></pre></div><p>To calculate our final number, and get our first gold star for the challenge, we need to count the passports for which our function <code>hasAllRequiredFields</code> returns true:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>main</span>() {
</span></span><span style=display:flex><span>    println(passports.count(Passport<span style=color:#fe8019>::</span>hasAllRequiredFields))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, we have successfully solved the first part of the challenge and can set our sights on the next star in our journey.</p><p>Find the full code for the first part of the challenge on <a href=https://github.com/kotlin-hands-on/advent-of-code-2020/blob/master/src/day04/day4_1.kt>GitHub</a>.</p><h2 id=solving-day-4-part-2>Solving Day 4, Part 2</h2><p>In part two of the challenge, we also need to ensure that each field on the passport contains a valid value. We are given an additional list of rules to accomplish this task, which you can again find in the <a href=https://adventofcode.com/2020/day/4>problem description</a>. Years need to fall into specific ranges, as does a person&rsquo;s height depending on the unit of measurement. Colors need to come from a prespecified list or follow certain patterns, and numbers must be correctly formatted.</p><h3 id=a-refactoring-excursion>A refactoring excursion</h3><p>Before we start building the solution for part 2, let’s briefly reflect on our code and find possible changes that will make adding this functionality easier for us. At this point in the challenge, we <em>know</em> that our <code>Passport</code> class will need access to the different field names and their associated values. The classical data structure to store such kind of associative-dictionary information is a map. Let’s refactor our code to store passport information in a map instead of a string.</p><p>Because turning an input string into a map is still a process that’s associated with the <code>Passport</code>, I like encapsulating such logic in a companion object “factory” function. In this case, we can aptly call it <code>fromString</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>companion</span> <span style=color:#fe8019>object</span> {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>fun</span> <span style=color:#fabd2f>fromString</span>(s: String): Passport {
</span></span></code></pre></div><p>The implementation for <code>fromString</code> partially reuses the normalization logic we had previously used in the first part of this challenge and expands it to create a map directly via Kotlin’s <code><a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/associate.html>associate</a></code> function:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>fromString</span>(s: String): Passport {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> fieldsAndValues = s.split(<span style=color:#b8bb26>&#34; &#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>, <span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>\r\n</span><span style=color:#b8bb26>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#fe8019>val</span> map = fieldsAndValues.associate {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>val</span> (key, <span style=color:#fe8019>value</span>) = <span style=color:#fe8019>it</span>.split(<span style=color:#b8bb26>&#34;:&#34;</span>)
</span></span><span style=display:flex><span>        key to <span style=color:#fe8019>value</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> Passport(map)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A <code>Passport</code> object now encapsulates a map of string keys and string values:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>class</span> Passport(<span style=color:#fe8019>private</span> <span style=color:#fe8019>val</span> map: Map&lt;String, String&gt;) {
</span></span></code></pre></div><p>Interestingly enough, this change makes the implementation of the first part of our challenge trivial. We can simply check that the key set of our map contains all required fields:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>hasAllRequiredFields</span>() = map.keys.containsAll(requiredFields)
</span></span></code></pre></div><h3 id=returning-to-solving-part-2>Returning to solving part 2</h3><p>For the second part of the challenge, we consider a passport valid if it contains all the required fields and has values that correspond to the official rules.</p><p>To ensure that all fields have valid values, we can use the <code>all</code> function to assert that a predicate holds true for every single key-value pair in our map:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>hasValidValues</span>(): Boolean =
</span></span><span style=display:flex><span>    map.all { (key, <span style=color:#fe8019>value</span>) <span style=color:#fe8019>-&gt;</span>
</span></span></code></pre></div><p>We can distinguish the different types of fields using a <code>when</code> expression. In this first step, we distinguish the different cases based on the keys in our map:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>when</span> (key) {
</span></span></code></pre></div><p>Each key we know gets a branch in this when statement. They all need to return a boolean value – <code>true</code> if the field is okay, <code>false</code> if the field violates the rules. The surrounding <code>all</code> predicate will then use those results to determine whether the passport as a whole is valid.</p><p>The <code>byr</code> (Birth Year), <code>iyr</code> (Issue Year), and <code>eyr</code> (Expiration Year) fields all require their value to be a 4-digit number falling into a particular range:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#b8bb26>&#34;byr&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span>.length <span style=color:#fe8019>==</span> <span style=color:#d3869b>4</span> <span style=color:#fe8019>&amp;&amp;</span> <span style=color:#fe8019>value</span>.toIntOrNull() <span style=color:#fe8019>in</span> <span style=color:#d3869b>1920.</span>.<span style=color:#d3869b>2002</span>
</span></span><span style=display:flex><span><span style=color:#b8bb26>&#34;iyr&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span>.length <span style=color:#fe8019>==</span> <span style=color:#d3869b>4</span> <span style=color:#fe8019>&amp;&amp;</span> <span style=color:#fe8019>value</span>.toIntOrNull() <span style=color:#fe8019>in</span> <span style=color:#d3869b>2010.</span>.<span style=color:#d3869b>2020</span>
</span></span><span style=display:flex><span><span style=color:#b8bb26>&#34;eyr&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span>.length <span style=color:#fe8019>==</span> <span style=color:#d3869b>4</span> <span style=color:#fe8019>&amp;&amp;</span> <span style=color:#fe8019>value</span>.toIntOrNull() <span style=color:#fe8019>in</span> <span style=color:#d3869b>2020.</span>.<span style=color:#d3869b>2030</span>
</span></span></code></pre></div><p>Note that our combined use of <code>toIntOrNull</code> together with the infix function <code>in</code> allows us to discard any non-numeric values, and ensure that they fall in the correct range.</p><p>We can apply a very similar rule to the <code>pid</code> (Passport ID) field. We ensure that the length of the value is correct and ensure that all characters belong to the set of digits:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#b8bb26>&#34;pid&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span>.length <span style=color:#fe8019>==</span> <span style=color:#d3869b>9</span> <span style=color:#fe8019>&amp;&amp;</span> <span style=color:#fe8019>value</span>.all(Char<span style=color:#fe8019>::</span>isDigit)
</span></span></code></pre></div><p>Validating <code>ecl</code> (eye color) just requires us to check whether the input is in a certain set of values, similar to the first part of our challenge:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#b8bb26>&#34;ecl&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span> <span style=color:#fe8019>in</span> setOf(<span style=color:#b8bb26>&#34;amb&#34;</span>, <span style=color:#b8bb26>&#34;blu&#34;</span>, <span style=color:#b8bb26>&#34;brn&#34;</span>, <span style=color:#b8bb26>&#34;gry&#34;</span>, <span style=color:#b8bb26>&#34;grn&#34;</span>, <span style=color:#b8bb26>&#34;hzl&#34;</span>, <span style=color:#b8bb26>&#34;oth&#34;</span>)
</span></span></code></pre></div><p>At this point, we have two more fields to validate: <code>hgt</code> (Height) and <code>hcl</code> (Hair Color). Both of them are a bit more tricky. Let’s look at the <code>hgt</code> field first.</p><p>The <code>hgt</code> (Height) field can contain a measurement either in centimeters or inches. Depending on the unit used, different values are allowed. Thankfully, both “cm” and “in” are two-character suffixes. This means we can again use Kotlin’s <code>when</code> function, grab the last two characters in the field value and differentiate the validation logic for centimeters and inches. Like our other number-validation logic, we parse the integer and check whether it belongs to a specific range. To do so, we also remove the unit suffix:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#b8bb26>&#34;hgt&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>when</span> (<span style=color:#fe8019>value</span>.takeLast(<span style=color:#d3869b>2</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;cm&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span>.removeSuffix(<span style=color:#b8bb26>&#34;cm&#34;</span>).toIntOrNull() <span style=color:#fe8019>in</span> <span style=color:#d3869b>150.</span>.<span style=color:#d3869b>193</span>
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;in&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span>.removeSuffix(<span style=color:#b8bb26>&#34;in&#34;</span>).toIntOrNull() <span style=color:#fe8019>in</span> <span style=color:#d3869b>59.</span>.<span style=color:#d3869b>76</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>else</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The last field to validate is <code>hcl</code> (Hair Color), which expects a <code>#</code> followed by exactly six hexadecimal digits – digits from <code>0</code> through <code>9</code>, and <code>a</code> through <code>f</code>. While Kotlin can parse base-16 numbers, we can use this case to show off the sledgehammer method for validating patterns – regular expressions. Those can be defined as Kotlin strings and converted using the <code>toRegex</code> function. Triple-quoted strings can help with escape characters:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#b8bb26>&#34;hcl&#34;</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>value</span> matches <span style=color:#b8bb26>&#34;&#34;&#34;#[0-9a-f]{6}&#34;&#34;&#34;</span>.toRegex()
</span></span></code></pre></div><p>Our hand-crafted pattern matches exactly one hashtag, then six characters from the group of <code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>.</p><p>As a short aside for performance enthusiasts: <code>toRegex</code> is a relatively expensive function, so it may be worth moving this function call into a constant. The same also applies to the set used in the validation for <code>ecl</code> – currently, it is initialized on each test.</p><p>Because the whole <code>when</code>-block is used as an expression, we need to ensure that all possible branches are covered. In our case, that just means adding an <code>else</code> branch, which simply returns <code>true</code> – just because a passport has a field we don’t know about doesn’t mean it can’t still be valid.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>else</span> <span style=color:#fe8019>-&gt;</span> <span style=color:#fe8019>true</span>
</span></span></code></pre></div><p>With that, we have covered every rule outlined to us by the problem statement. To get our reward, we can now just count the passports that contain all required fields and have valid values:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>fun</span> <span style=color:#fabd2f>partTwo</span>() {
</span></span><span style=display:flex><span>    println(passports.count { <span style=color:#fe8019>it</span>.hasAllRequiredFields() <span style=color:#fe8019>&amp;&amp;</span> <span style=color:#fe8019>it</span>.hasValidValues() })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We end up with a resulting number, which we can exchange for the second star. We’re clear for boarding our virtual flight. Though this was probably not the last challenge that awaits us…</p><p>Find the complete solution for the second part of the challenge on <a href=https://github.com/kotlin-hands-on/advent-of-code-2020/blob/master/src/day04/day4.kt>GitHub</a>.</p><h2 id=conclusion>Conclusion</h2><p>For today’s challenge, we came up with an elegant solution to validate specific string information, which we extracted using utility functions offered by the Kotlin standard library. As the challenge continued, we reflected on our code, identified more fitting data structures, and changed our logic to accommodate it. Using Kotlin’s <code>when</code> statement, we were able to keep the validation logic concise and all in one place. We saw multiple different ways of how to validate input – working with ranges, checking set membership, or matching a particular regular expression, for example.</p><p>Many real-world applications have similar requirements for input validation. Hopefully, some of the tips and tricks you’ve seen in the context of this little challenge will also be helpful when you need to write some validation logic on your own.</p><p>To continue puzzling yourself, check out <a href=https://adventofcode.com/>adventofcode.com</a>, whose organizers kindly permitted us to use their problem statements for this series.</p><p>If you want to see more solutions for Advent of Code challenges in the form of videos, subscribe to our <a href=https://www.youtube.com/kotlin>YouTube channel</a> and hit the bell to get notified when we continue our idiomatic journey. More puzzle solutions are coming your way!</p><div><div>Tags:</div><ul><li><a href=/tags/kotlin/>kotlin</a></li><li><a href=/tags/adventofcode/>adventofcode</a></li><li><a href=/tags/codenewbie/>codenewbie</a></li><li><a href=/tags/100daysofcode/>100daysofcode</a></li></ul></div></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>