<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Advanced Kotlin Collection Functionality | Sebastian Aigner</title><link rel=stylesheet href=https://sebi.io/sass/main.1062dd691b84b3ea042cce5aecb22abbae6d1a58288b48fbcb72443c8f1930dd.css integrity="sha256-EGLdaRuEs+oELM5a7LIqu65tGlgoi0j7y3JEPI8ZMN0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header class=site-header><div class=wrapper><a class=site-title rel=author href=/>Sebastian Aigner</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg viewBox="0 0 18 15" width="18" height="15"><path d="M18 1.484c0 .82-.665 1.484-1.484 1.484H1.484C.665 2.969.0 2.304.0 1.484.0.665.665.0 1.484.0h15.032C17.335.0 18 .665 18 1.484zm0 6.032C18 8.335 17.335 9 16.516 9H1.484C.665 9 0 8.335.0 7.516c0-.82.665-1.484 1.484-1.484h15.032C17.335 6.031 18 6.696 18 7.516zm0 6C18 14.335 17.335 15 16.516 15H1.484C.665 15 0 14.335.0 13.516c0-.82.665-1.483 1.484-1.483h15.032C17.335 12.031 18 12.695 18 13.516z"/></svg></span></label><div class=trigger><a class=page-link href=/>Home</a>
<a class=page-link href=/micro/>Microblah</a>
<a class=page-link aria-current=true class=ancestor href=/posts/>Posts</a>
<a class=page-link href=/tags/>Tags</a></div></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Advanced Kotlin Collection Functionality</h1><p class=post-meta><time class=dt-published datetime=2021-06-14T00:00:00+00:00>June 14, 2021</time></p></header><div class="post-content e-content"><p>This blog post accompanies a video from our <strong>YouTube series</strong> which you can find on our <a href=https://kotl.in/video>Kotlin YouTube channel</a>, or <strong>watch here</strong> directly!</p><iframe width=560 height=315 src="https://www.youtube.com/embed/N4CpLxGJlq0?si=BD4VNf3kkvCEtJiq" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>Today, we are learning about advanced functions that we can use to work with and manipulate all kinds of Kotlin collections!</p><h2 id=checking-predicates-any-none-and-all>Checking predicates: <code>any</code>, <code>none</code> and <code>all</code></h2><p>Let’s warm up by having a look at a selection of functions that allow us to check conditions for our collection elements.</p><p>They’re called <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html><code>any</code></a>, <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/none.html><code>none</code></a>, and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/all.html><code>all</code></a>. Each of them takes a <em>predicate</em> – so a function that returns <code>true</code> or <code>false</code> – and checks whether the collection fits this predicate.</p><p>Let’s say we have a group of friends (which is really just a <code>List&lt;Person></code>, each featuring a <code>name</code>, <code>age</code>, and maybe a <code>driversLicense</code>):</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>data</span> <span style=color:#fe8019>class</span> Person(<span style=color:#fe8019>val</span> name: String, <span style=color:#fe8019>val</span> age: Int, <span style=color:#fe8019>val</span> driversLicense: Boolean = <span style=color:#fe8019>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> friendGroup = listOf(
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Jo&#34;</span>, <span style=color:#d3869b>19</span>),
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Mic&#34;</span>, <span style=color:#d3869b>15</span>),
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Hay&#34;</span>, <span style=color:#d3869b>33</span>, <span style=color:#fe8019>true</span>),
</span></span><span style=display:flex><span>    Person(<span style=color:#b8bb26>&#34;Cal&#34;</span>, <span style=color:#d3869b>25</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>When we want to check if the group can travel by car, we want to check if <em>any</em> of them have a driver&rsquo;s license – so we use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html><code>any</code></a> function. It returns <code>true</code> if there is <em>at least one element</em> in our collection for which the predicate returns <code>true</code>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> groupCanTravel = friendGroup.any { <span style=color:#fe8019>it</span>.driversLicense }
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// true
</span></span></span></code></pre></div><p>As another example, let’s say we want to check if this group of friends is allowed to enter a club – for this, we would need to make sure that <em>none</em> of the folks in the group are underage!</p><p>Here, we can use the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/none.html><code>none</code></a> function, which only returns <code>true</code> when there is <em>not a single element in our collection</em> that holds true for our predicate:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> groupGetsInClub = friendGroup.none { <span style=color:#fe8019>it</span>.age &lt; <span style=color:#d3869b>18</span> }
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// false
</span></span></span></code></pre></div><p>The third function in the bunch is the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/all.html><code>all</code></a> function. At this point, you can probably spot the pattern – <code>all</code> returns <code>true</code>, if each and every element in our collection matches our predicate. We could use it to check whether all names in our friend group are short:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> groupHasShortNames = friendGroup.all { <span style=color:#fe8019>it</span>.name.length &lt; <span style=color:#d3869b>4</span> }
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// true
</span></span></span></code></pre></div><h3 id=predicates-for-empty-collections>Predicates for empty collections</h3><p>While on the topic, let&rsquo;s have a little brain teaser: How do <code>any</code>, <code>none</code>, and <code>all</code> behave for <em>empty collections</em>?</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> nobody = emptyList&lt;Person&gt;()
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// what happens here?
</span></span></span></code></pre></div><p>Let’s look at <code>any</code> first. There is no element that can satisfy the predicate, so it returns <code>false</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>nobody.any { <span style=color:#fe8019>it</span>.driversLicense }
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// false
</span></span></span></code></pre></div><p>The same goes for <code>none</code> – there is no function that can violate our predicate, so it returns true:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>nobody.none { <span style=color:#fe8019>it</span>.age &lt; <span style=color:#d3869b>18</span> }
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// true
</span></span></span></code></pre></div><p>The <code>all</code> function, however, returns <code>true</code> with an empty collection. This may surprise you in the first moment:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>nobody.all { <span style=color:#fe8019>it</span>.name.count() &lt; <span style=color:#d3869b>4</span> } 
</span></span></code></pre></div><p>But this is quite intentional and sound: You can&rsquo;t name an element that <em>violates</em> the predicate. Therefore, the predicate has to be true for <em>all elements in the collection</em> – even if there are <em>none</em>!</p><p>This might feel a bit mind-bending to think about at first, but you’ll find that this concept, which is called the <a href=https://en.wikipedia.org/wiki/Vacuous_truth>vacuous truth</a>, actually plays very well with checking conditions, and expressing logic in program code.</p><p><img src=/assets/stdlibsafari4/thg07e0ao215ck2lwm1z.png alt="&ldquo;Vacuous truth&rdquo; on Wikipedia"></p><h2 id=collection-parts-chunked-and-windowed>Collection parts: <code>chunked</code> and <code>windowed</code></h2><p>With our brain freshly teased, let’s move on to the next topic, and learn about how to break collections into parts!</p><h3 id=the-chunked-function>The <code>chunked</code> function</h3><p>If we have a collection that just contains a bunch of items, we can cut up the list into individual chunks of a certain size by using the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/chunked.html><code>chunked</code></a> function. What we get back is a list of lists, where each element is a _chunk _of our original list:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> objects = listOf(<span style=color:#b8bb26>&#34;🌱&#34;</span>, <span style=color:#b8bb26>&#34;🚀&#34;</span>, <span style=color:#b8bb26>&#34;💡&#34;</span>, <span style=color:#b8bb26>&#34;🐧&#34;</span>, <span style=color:#b8bb26>&#34;⚙️&#34;</span>, <span style=color:#b8bb26>&#34;🤖&#34;</span>, <span style=color:#b8bb26>&#34;📚&#34;</span>)
</span></span><span style=display:flex><span>println(objects.chunked(<span style=color:#d3869b>3</span>))
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [[🌱, 🚀, 💡], [🐧, ⚙️, 🤖], [📚]]
</span></span></span></code></pre></div><p>In the example above, we break our list of random objects (represented with emojis) apart, using a chunk size of 3.</p><ul><li><p>The first <em>element</em> in our result is in itself a <em>list</em> which contains our first three objects – <code>[🌱, 🚀, 💡]</code>.</p></li><li><p>The second element is once again a chunk, and contains the three elements that follow after that – <code>[🐧, ⚙️, 🤖]</code>.</p></li><li><p>The last element is also a chunk – but since we ran out of elements to fill it with three items, it only contains the book stack - <code>[📚]</code>.</p></li></ul><p>In typical standard library fashion, the <code>chunked</code> function also provides a little bit of extra power. To immediately transform the chunks we just created, we can apply a <em>transformation function</em>. For example, we can reverse the order of elements in the resulting lists, without having to do another <code>map</code> call separately:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(objects.chunked(<span style=color:#d3869b>3</span>) { <span style=color:#fe8019>it</span>.reversed() })
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [[💡, 🚀, 🌱], [🤖, ⚙️, 🐧], [📚]]
</span></span></span></code></pre></div><p>To summarize: the <code>chunked</code> function cuts our original collection into lists of lists, where each list has the specified size.</p><h3 id=the-windowed-function>The <code>windowed</code> function</h3><p>Closely related is the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/windowed.html><code>windowed</code></a> function. It also returns a list of lists from our collection. Instead of cutting it up into pieces, however, this function generates a “sliding window” of our collection:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(objects.windowed(<span style=color:#d3869b>3</span>))
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [[🌱, 🚀, 💡], [🚀, 💡, 🐧], [💡, 🐧, ⚙️], [🐧, ⚙️, 🤖], [⚙️, 🤖, 📚]]
</span></span></span></code></pre></div><ul><li>The first window is once again the first three elements – <code>[🌱, 🚀, 💡]</code>.</li><li>The next window is <code>[🚀, 💡, 🐧]</code> – we simply “moved” our window of size 3 over by one, which includes some overlap.</li></ul><p>The <code>windowed</code> function can also be customized. We can change both <em>window</em> and <em>step</em> size, the latter being the number of elements that the window should “slide along” for each step:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(objects.windowed(<span style=color:#d3869b>4</span>, <span style=color:#d3869b>2</span>, partialWindows = <span style=color:#fe8019>true</span>))
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [[🌱, 🚀, 💡, 🐧], [💡, 🐧, ⚙️, 🤖], [⚙️, 🤖, 📚], [📚]]
</span></span></span></code></pre></div><p>As you can see in the example above, we can also control whether our result should contain <em>partial windows</em>. This changes the behavior when we’ve reached the end of our input collection, and we’re running out of elements.</p><p>With partial windows enabled, we just <em>keep sliding</em>, and we get the last elements trickling in, in the form of smaller windows, until we get a window which once again only contains the last element from our input collection – <code>[⚙️, 🤖, 📚], [📚]</code>.</p><p><code>windowed</code> also allows us to perform an additional transformation at the end, which can modify the individual windows directly:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(objects.windowed(<span style=color:#d3869b>4</span>, <span style=color:#d3869b>2</span>, <span style=color:#fe8019>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.reversed()
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [[🐧, 💡, 🚀, 🌱], [🤖, ⚙️, 🐧, 💡], [📚, 🤖, ⚙️], [📚]]
</span></span></span></code></pre></div><h2 id=un-nesting-collections-flatten-and-flatmap>Un-nesting Collections: Flatten and Flatmap</h2><p>The <code>chunked</code> and <code>windowed</code> functions, along with some others all return nested collections – lists of lists. What if we want to <em>un-nest</em> these, turning them back into flat lists of elements? As usual, we do not need to fear, because the standard library has got us covered.</p><p>We can call the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/flatten.html><code>flatten</code></a> function on a collection of collections. As you may suspect, the result is a single list of all the elements that were originally contained inside of our nested collections:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> objects = listOf(<span style=color:#b8bb26>&#34;🌱&#34;</span>, <span style=color:#b8bb26>&#34;🚀&#34;</span>, <span style=color:#b8bb26>&#34;💡&#34;</span>, <span style=color:#b8bb26>&#34;🐧&#34;</span>, <span style=color:#b8bb26>&#34;⚙️&#34;</span>, <span style=color:#b8bb26>&#34;🤖&#34;</span>, <span style=color:#b8bb26>&#34;📚&#34;</span>)
</span></span><span style=display:flex><span>objects.windowed(<span style=color:#d3869b>4</span>, <span style=color:#d3869b>2</span>, <span style=color:#fe8019>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.reversed()
</span></span><span style=display:flex><span>}.flatten()
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [🐧, 💡, 🚀, 🌱, 🤖, ⚙️, 🐧, 💡, 📚, 🤖, ⚙️, 📚]
</span></span></span></code></pre></div><p>This is also a good point to talk about the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/flat-map.html><code>flatMap</code></a> function. <code>flatMap</code> is like a combination of first using <code>map</code>, and then using <code>flatten</code> – It takes a lambda which generates a <em>collection</em> from each of the elements in our input collection:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> lettersInNames = listOf(<span style=color:#b8bb26>&#34;Lou&#34;</span>, <span style=color:#b8bb26>&#34;Mel&#34;</span>, <span style=color:#b8bb26>&#34;Cyn&#34;</span>).flatMap {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>it</span>.toList()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>println(lettersInNames)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [L, o, u, M, e, l, C, y, n]
</span></span></span></code></pre></div><p>In the example above, the function that we provide creates a <em>list</em> for each element in our input collection, containing the letters of the original string. Next, that collection of collections gets flattened. As desired, we end up with a plain list of elements – the list of characters from the names of the original collection.</p><p>If you are doing an operation on a list, which in turn generates a collection for each one of the input elements, consider if <code>flatMap</code> can help you simplify your code!</p><h2 id=combining-collections-zip-and-unzip>Combining collections: <code>zip</code> and <code>unzip</code></h2><p>So far, we have always looked at a single collection, and what we can do with it. Let&rsquo;s learn about a way to combine two collections, and create a new one from them – it&rsquo;s time to <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/zip.html><code>zip</code></a>!</p><h3 id=the-zip-function>The <code>zip</code> function</h3><p>Assume we have two collections, where the elements at each index are somehow related. For example, this could be a list of cities in Germany, and we have another list of German license plates that correspond to those cities:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> germanCities = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Aachen&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;Bielefeld&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;München&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> germanLicensePlates = listOf(
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;AC&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;BI&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b8bb26>&#34;M&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(germanCities.zip(germanLicensePlates))
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [(Aachen, AC), (Bielefeld, BI), (München, M)]
</span></span></span></code></pre></div><p>As you can see, by zipping these two collections, we get a <em>list of pairs</em>, where each pair contains the elements with the same index from the original two collections.</p><p>Metaphorically, this is similar to a zipper on a jacket, where the teeth match up one by one. We zip together the elements of our collection, and we get pairs of each city and its corresponding license plate.</p><p>For an extra bit of flair, we can also call the <code>zip</code> function using infix notation:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(germanCities zip germanLicensePlates)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [(Aachen, AC), (Bielefeld, BI), (München, M)]
</span></span></span></code></pre></div><p><code>zip</code> can also take a transformation function. We can pass a lambda that receives the values of the individual zipped pairs, and we can apply a transformation:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>println(germanCities.zip(germanLicensePlates) { city, plate <span style=color:#fe8019>-&gt;</span>
</span></span><span style=display:flex><span>    city.uppercase() to plate.lowercase()
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [(AACHEN, ac), (BIELEFELD, bi), (MÜNCHEN, m)]
</span></span></span></code></pre></div><h3 id=the-unzip-function>The <code>unzip</code> function</h3><p>The standard library also contains the inverse function, called <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/unzip.html><code>unzip</code></a>, which takes a list of pairs, and splits them back into a pair of two separate lists:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> citiesToPlates = germanCities.zip(germanLicensePlates) { city, plate <span style=color:#fe8019>-&gt;</span>
</span></span><span style=display:flex><span>    city.uppercase() to plate.lowercase()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> (cities, plates) = citiesToPlates.unzip()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(cities)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [AACHEN, BIELEFELD, MÜNCHEN]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>println(plates)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [ac, bi, m]
</span></span></span></code></pre></div><p>The example above uses a destructuring declaration to easily access both of them.</p><h3 id=the-zipwithnext-function>The <code>zipWithNext</code> function</h3><p>In a way, <code>zipWithNext</code> is really a specialized case of the <code>windowed</code> function we got to know today: Instead instead of zipping together two separate lists element by element, this function takes one collection, and zips each of its items with the one that follows it:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> random = listOf(<span style=color:#d3869b>3</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>4</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>9</span>, <span style=color:#d3869b>2</span>, <span style=color:#d3869b>6</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>4</span>)
</span></span><span style=display:flex><span>println(random.zipWithNext())
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [(3, 1), (1, 4), (4, 1), (1, 5), (5, 9), (9, 2), (2, 6), (6, 5), (5, 4)]
</span></span></span></code></pre></div><p>In the example above, we&rsquo;re zipping together a list of numbers. If we want to check the “change” – how much the value increments or decrements each step – we can express this quite elegantly using <code>zipWithNext</code>. We provide a lambda that receives a pair of one number and the one that follows immediately after:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> random = listOf(<span style=color:#d3869b>3</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>4</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>9</span>, <span style=color:#d3869b>2</span>, <span style=color:#d3869b>6</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>4</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> changes = random.zipWithNext { a, b <span style=color:#fe8019>-&gt;</span> b - a }
</span></span><span style=display:flex><span>println(changes)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [-2, 3, -3, 4, 4, -7, 4, -1, -1]
</span></span></span></code></pre></div><h2 id=custom-aggregations-reduce-and-fold>Custom aggregations: <code>reduce</code> and <code>fold</code></h2><p>We have finally arrived at the <em>grand finale</em> for this post – functions that help us build custom aggregations.</p><h3 id=the-reduce-function>The <code>reduce</code> function</h3><p>Let’s set the scene with a small callback – in the [previous post]({% post_url 2021-03-29-Diving-into-Kotlin-collections %}), we learned about functions like <code>sum</code>, <code>average</code>, <code>count</code>, and functions to receive the minimum and maximum elements inside a collection. All of these <em>reduce</em> our collection to a single value.</p><p>It&rsquo;s possible that we find ourselves in a situation where there’s no out-of-the-box function for how we want to generate a single value for our collection. For example, we may want to multiply all numbers in a list, instead of summing them.</p><p>In this case, we can rely on the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce.html><code>reduce</code></a> function as a more generic version for aggregating a collection:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> random = listOf(<span style=color:#d3869b>3</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>4</span>, <span style=color:#d3869b>1</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>9</span>, <span style=color:#d3869b>2</span>, <span style=color:#d3869b>6</span>, <span style=color:#d3869b>5</span>, <span style=color:#d3869b>4</span>)
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> multiplicativeAggregate = random.reduce { acc, <span style=color:#fe8019>value</span> <span style=color:#fe8019>-&gt;</span> acc * <span style=color:#fe8019>value</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(multiplicativeAggregate)
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 129600
</span></span></span></code></pre></div><p>As seen in the example above, we call the reduce function with a lambda block which receives two parameters:</p><ul><li>An accumulator, which has the same type as our collection, and</li><li>An individual item from our collection.</li></ul><p>The task of the lambda function is to <em>return a new accumulator</em>. Each invocation, one after the other, receives not only the <em>current element</em>, but also the <em>result of the previous calculation</em>, inside the accumulator.</p><ul><li>The function starts with the first element of our collection in the accumulator.</li><li>Then it runs our operation – in this example, we multiply the accumulator (which right now is the first number) with the current element (which is the second number).</li><li>We’ve calculated a new value, which will be stored in the accumulator, and used when our function is called once more with the third element</li></ul><p>This cycle repeats, and we continue to gradually build up the final result in our accumulator. One might even say we’re <em>accumulating</em> that result!</p><p><img src=/assets/stdlibsafari4/ri4o64h51mzhg2cwe4g2.png alt=image></p><p>Once we’ve gone through all the elements in our collection, <code>reduce</code> returns the final value that’s inside the accumulator.</p><p>As you can see, with <code>reduce</code>, we can hide a lot of mechanics for aggregating our collection behind one function call, and stay true to Kotlin’s concise nature.</p><h3 id=the-fold-function>The <code>fold</code> function</h3><p>But we can actually go beyond this, and can take this versatility one step further – with the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html><code>fold</code></a> operation. Remember – when we used <code>reduce</code>, the iteration starts with the first element of our input collection in the accumulator.</p><p>With the <code>fold</code> function, we get to specify our own accumulator – and in fact, it can even have a different type than the items in our input collection! As an example, we can take a list of words, and multiply the number of their characters together using <code>fold</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fe8019>val</span> fruits = listOf(<span style=color:#b8bb26>&#34;apple&#34;</span>, <span style=color:#b8bb26>&#34;cherry&#34;</span>, <span style=color:#b8bb26>&#34;banana&#34;</span>, <span style=color:#b8bb26>&#34;orange&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#fe8019>val</span> multiplied = fruits.fold(<span style=color:#d3869b>1</span>) { acc, <span style=color:#fe8019>value</span> <span style=color:#fe8019>-&gt;</span>
</span></span><span style=display:flex><span>    acc * <span style=color:#fe8019>value</span>.length
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>println(multiplied) <span style=color:#928374;font-style:italic>// 1080
</span></span></span></code></pre></div><p>The underlying mechanism is the same – the lambda passed to the <code>fold</code> function gets called with an accumulator and a value, and calculates a new accumulator. The difference is that we specify the initial value of the accumulator ourselves.</p><p>(<em>Note that we pass <code>1</code> as an initial value for our accumulator, and not <code>0</code>. That’s because for multiplication, 1 is the <a href=https://en.wikipedia.org/wiki/Identity_element>neutral element</a></em>)</p><p>Both <code>fold</code> and <code>reduce</code> come in a number of other flavors, as well:</p><p>– the sibling functions <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce-right.html><code>reduceRight</code></a> and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold-right.html><code>foldRight</code></a> change the order of iteration</p><ul><li><a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce-or-null.html><code>reduceOrNull</code></a> allows you to work with empty collections without throwing exceptions.</li><li><a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/running-fold.html><code>runningFold</code></a> and <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/running-reduce.html><code>runningReduce</code></a> don’t just return a single value representing the final state of the accumulator, but instead return a list of all the intermediate accumulator values as well.</li></ul><h2 id=thats-it>That&rsquo;s it!</h2><p>This concludes my overview of some advanced collection operations in Kotlin – I hope you found this post useful, and have learned something new!</p><p>Maybe you can find a point in your code where a predicate, some zipping, chunking or windowing could come in handy! Or maybe you want to explore by defining your own aggregations functions based on the <code>reduce</code> or <code>fold</code> functions.</p><p>Take care!</p><div><div>Tags:</div><ul><li><a href=/tags/kotlin/>kotlin</a></li><li><a href=/tags/programming/>programming</a></li><li><a href=/tags/android/>android</a></li><li><a href=/tags/productivity/>productivity</a></li></ul></div></div></div></main><footer><footer class="site-footer h-card"><data class=u-url href></data><div class=wrapper><div class=footer-col-wrapper><div class=footer-col><p class=feed-subscribe><svg class="svg-icon orange"/><span>Subscribe</span></a></p><ul class=contact-list></ul></div><div class=footer-col><p>Thanks for stopping by my corner of the internet :)</p></div></div></div></footer></footer></body></html>